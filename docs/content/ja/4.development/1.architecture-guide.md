---
title: アーキテクチャガイド
description: Arereのレイヤードアーキテクチャ設計と実装ガイド
---

# アーキテクチャガイド

## 概要

Arereプロジェクトは、**Clean Architecture / レイヤードアーキテクチャ** に基づいて設計されています。

**設計原則**:
- ビジネスロジックとUIロジックを分離
- テスタビリティの向上
- 保守性・拡張性の向上
- 単一責任原則（SRP）の徹底

---

## レイヤー構造

### レイヤー分離の原則

```
┌─────────────────────────────────────┐
│   Presentation Layer                │  ← ユーザーとのやり取り
│   - React/Ink Components            │
│   - UI Hooks                        │
│   - Modes (UI/Headless)             │
└──────────────┬──────────────────────┘
               │ calls
┌──────────────▼──────────────────────┐
│   Application Layer                 │  ← ユースケース実行
│   - Services (orchestration)        │
│   - ConfigService                   │
│   - PluginService                   │
└──────────────┬──────────────────────┘
               │ uses
┌──────────────▼──────────────────────┐
│   Domain Layer                      │  ← ビジネスロジック
│   - Action Types                    │
│   - Type Definitions                │
│   - Pure Functions (minimal)        │
└──────────────┬──────────────────────┘
               │ depends on
┌──────────────▼──────────────────────┐
│   Infrastructure Layer              │  ← 外部システム
│   - File I/O (config, plugin)       │
│   - i18n                            │
│   - Shell Execution                 │
│   - Prompt System                   │
│   - Output Rendering                │
└─────────────────────────────────────┘
         ↕
┌─────────────────────────────────────┐
│   Shared Layer                      │  ← 共通ユーティリティ
│   - Logger                          │
│   - Error Handling                  │
│   - Path Utilities                  │
└─────────────────────────────────────┘
```

**依存関係のルール**:
- 上位層は下位層に依存できる
- 下位層は上位層に依存してはいけない
- Domain層は Infrastructure層の型のみを import 可能
- Shared層は全ての層から使用可能

---

## ディレクトリ構造

```
src/
├── cli.ts                           # CLIエントリーポイント
├── index.ts                         # ライブラリAPI公開
│
├── core/                            # コア層（Action loading system）
│   ├── loader.ts                    # jiti を使った動的Action読み込み
│   ├── registry.ts                  # ActionRegistry（last-wins）
│   ├── resolver.ts                  # Actionパス解決
│   └── cache.ts                     # Actionキャッシュ
│
├── domain/                          # ドメイン層
│   ├── action/                      # Action型定義・ビジネスロジック
│   │   ├── types.ts                 # Action, ActionContext, ActionMeta
│   │   ├── context.ts               # createActionContext
│   │   ├── executor.ts              # runAction
│   │   └── defineAction.ts          # defineAction ヘルパー
│   ├── plugin/                      # Plugin型定義・ビジネスロジック
│   │   ├── types.ts                 # ArerePlugin, PluginMeta, LoadedPlugin
│   │   ├── definePlugin.ts          # definePlugin() ヘルパー（Pure関数）
│   │   └── manager.ts               # PluginManager（依存注入パターン）
│   └── types/                       # 共通型定義
│       ├── control.ts               # VisualFeedback, ControlAPI
│       └── common.ts                # 共通型
│
├── infrastructure/                  # インフラ層（外部システム）
│   ├── config/                      # 設定管理（Unified Manager API）
│   │   ├── manager.ts               # FileConfigManager 統合実装（read/write）
│   │   ├── errors.ts                # Config専用エラークラス
│   │   ├── schema.ts                # Zod schema定義 + defaultConfig
│   │   ├── types.ts                 # ConfigLayer等の型定義
│   │   ├── utils.ts                 # ユーティリティ関数（merge, nested-value）
│   │   ├── override-detector.ts     # オーバーライド検出
│   │   └── paths.ts                 # 設定ファイルパス
│   │
│   ├── plugin/                      # プラグインシステム（Infrastructure層）
│   │   ├── detector.ts              # npm経由のプラグイン検出（FS依存）
│   │   ├── loader.ts                # プラグイン読み込み（jiti依存）
│   │   ├── resolver.ts              # プラグインパス解決（システムコマンド依存）
│   │   └── index.ts                 # createPluginManager() ファクトリ関数
│   │
│   ├── i18n/                        # 国際化（i18next）
│   │   ├── index.ts                 # i18n初期化
│   │   ├── scoped-translation.ts    # スコープ付き翻訳
│   │   ├── registerTranslations.ts  # 動的翻訳登録
│   │   └── types.ts                 # 型安全な翻訳キー（自動生成）
│   │
│   ├── shell/                       # シェル実行
│   │   └── executor.ts              # $ tagged template executor
│   │
│   ├── prompt/                      # プロンプトシステム
│   │   ├── renderer.ts              # PromptRenderer（2層プロンプト）
│   │   ├── text.ts                  # text()
│   │   ├── select.ts                # select()
│   │   ├── confirm.ts               # confirm()
│   │   ├── multiSelect.ts           # multiSelect()
│   │   └── backends/
│   │       └── readline-backend.ts  # Headless mode用readline
│   │
│   ├── integrations/                # 外部ツール連携
│   │   ├── tmux.ts                  # tmux連携
│   │   └── zellij.ts                # zellij連携
│   │
│   └── output/                      # 出力レンダリング
│       └── plain-renderer.ts        # PlainTextRenderer
│
├── application/                     # アプリケーション層
│   └── services/                    # ビジネスロジック調整
│       ├── ConfigService.ts         # 設定変更ワークフロー
│       └── PluginService.ts         # プラグイン管理ワークフロー
│
├── presentation/                    # プレゼンテーション層
│   ├── ui/                          # React/Ink UI
│   │   ├── layouts/
│   │   │   ├── App.tsx              # メインアプリケーション
│   │   │   └── Header.tsx           # ヘッダー
│   │   │
│   │   ├── components/              # 再利用可能コンポーネント
│   │   │   ├── action/
│   │   │   │   ├── ActionList.tsx
│   │   │   │   └── ActionFuzzySearch.tsx
│   │   │   ├── prompt/
│   │   │   │   ├── PromptRenderer.tsx
│   │   │   │   └── parts/          # 入力部品
│   │   │   ├── settings/
│   │   │   │   ├── LayerSelector.tsx
│   │   │   │   └── OverrideIndicator.tsx
│   │   │   └── routing/
│   │   │       └── ScreenRouter.tsx
│   │   │
│   │   ├── pages/                   # 画面コンポーネント
│   │   │   ├── execution/
│   │   │   │   ├── Executing.tsx
│   │   │   │   ├── Success.tsx
│   │   │   │   └── Error.tsx
│   │   │   ├── help/
│   │   │   │   └── Help.tsx
│   │   │   └── settings/
│   │   │       ├── Settings.tsx
│   │   │       ├── components/
│   │   │       ├── hooks/
│   │   │       └── plugins/
│   │   │
│   │   ├── hooks/                   # カスタムフック
│   │   │   ├── app/                 # アプリケーション状態
│   │   │   │   ├── useAppState.ts
│   │   │   │   ├── useKeyboardInput.ts
│   │   │   │   ├── useActionExecution.ts
│   │   │   │   ├── useConfigManagement.ts
│   │   │   │   └── usePluginManagement.ts
│   │   │   └── useTerminalSize.ts
│   │   │
│   │   ├── control/                 # タイミング・フィードバック制御
│   │   │   ├── types.ts
│   │   │   ├── timing.ts
│   │   │   ├── spinner.ts
│   │   │   ├── progress.ts
│   │   │   └── terminal.ts
│   │   │
│   │   ├── types.ts                 # UI型定義
│   │   ├── schema-to-fields.ts      # Zod schema → UI fields変換
│   │   └── utils/
│   │       └── action.ts
│   │
│   └── modes/                       # 実行モード
│       ├── ui-mode.tsx              # インタラクティブUI
│       └── headless-mode.ts         # CI/CD用ヘッドレスモード
│
└── shared/                          # 共有層（全層から利用可能）
    └── utils/
        ├── logger.ts                # pino ベースロガー
        ├── error.ts                 # エラーフォーマット
        └── path.ts                  # パスユーティリティ
```

---

## 各層の責務と実装例

### 1. Core層

**責務**:
- Actionの動的読み込み（jiti使用）
- ActionRegistry管理
- パス解決・キャッシュ

**実装例**:
```typescript
// src/core/loader.ts
export async function loadActions(paths: string[]): Promise<Action[]> {
  const actions: Action[] = []

  for (const filePath of paths) {
    try {
      const action = await loadAction(filePath)  // jitiで動的読み込み
      actions.push(action)
    } catch (error) {
      logger.warn(`Failed to load action: ${filePath}`, error)
    }
  }

  return actions
}

// src/core/registry.ts
export class ActionRegistry {
  private actions = new Map<string, Action>()

  register(action: Action): void {
    // Last-wins: 後から登録されたものが優先
    this.actions.set(action.meta.name, action)
  }
}
```

### 2. Domain層

**責務**:
- Action型定義
- 共通型定義
- ビジネスロジック（最小限）

**特徴**:
- Infrastructure層の型をimport可能
- 純粋関数を推奨（必須ではない）

**実装例**:
```typescript
// src/domain/action/types.ts
export interface Action<TKeys extends string = string> {
  meta: ActionMeta
  filePath: string
  run: (context: ActionContext<TKeys>) => Promise<void>
  translations?: Record<string, Record<string, unknown>>
  pluginNamespace?: string
  pluginMeta?: import('@/domain/plugin/types.js').PluginMeta
}

export interface ActionContext<TKeys extends string = string> {
  tui: TUIAPI
  $: ShellExecutor
  env: Record<string, string | undefined>
  t: TranslationFunction<TKeys>
  cwd: string
  pluginConfig?: Record<string, unknown>
  config: import('@/infrastructure/config/schema.js').ArereConfig  // マージ済み設定
}

// src/domain/action/defineAction.ts
export function defineAction<TKeys extends string = string>(
  definition: ActionDefinition<TKeys>
): Action<TKeys> {
  // アクション定義のヘルパー関数
  return {
    meta: {
      name: definition.name || deriveNameFromFilename(),
      description: definition.description,
      category: definition.category,
      tags: definition.tags,
    },
    filePath: '',  // loaderがセット
    run: definition.run,
    translations: definition.translations,
  }
}
```

### 3. Infrastructure層

**責務**:
- 外部システムとのやり取り
- ファイルI/O
- 技術的な詳細の隠蔽

**Unified Manager Pattern (Repository/Writer統合)**:
- Read/Write操作を1つのクラスに統合（FileConfigManager）
- DI不要でシンプルなAPI
- Single Source of Truth（マージロジックの一元化）
- **主な改善**:
  - Repository/Writer分離の廃止（9ファイル → 6ファイル、-33%）
  - DIパターンの削除（より直感的なAPI）
  - 型安全性の向上（`@ts-expect-error` の削除）

**実装例**:
```typescript
// src/infrastructure/config/manager.ts (統合Manager)
export class FileConfigManager {
  private cwd: string

  constructor(cwd: string = process.cwd()) {
    this.cwd = cwd
  }

  // --- Read Operations ---

  async loadMerged(cwd: string = this.cwd): Promise<ArereConfig> {
    const layered = await this.loadAll(cwd)
    return mergeConfigs(layered)  // workspace > user > defaults
  }

  async loadLayer(layer: ConfigLayer, cwd: string = this.cwd): Promise<Partial<ArereConfig> | null> {
    const configPath = getConfigPath(layer, cwd)
    return await this.loadConfigFile(configPath)
  }

  async loadAll(cwd: string = this.cwd): Promise<LayeredConfig> {
    const [user, workspace] = await Promise.all([
      this.loadLayer('user', cwd),
      this.loadLayer('workspace', cwd),
    ])
    return { user, workspace }
  }

  // --- Write Operations ---

  async save(layer: ConfigLayer, key: string, value: unknown, cwd: string = this.cwd): Promise<void> {
    const configPath = getConfigPath(layer, cwd)

    // 1. 既存設定を読み込み
    const existing = await this.loadRawConfigFile(configPath)

    // 2. ネスト値を更新（utils.ts の setNestedValue を使用）
    const updated = setNestedValue(current || {}, key, value)

    // ファイルに書き込み（低レベルAPI統合）
    await this.saveConfigObjectToFile(configPath, updated)
  }

  async delete(layer: ConfigLayer, key: string, cwd: string = this.cwd): Promise<void> {
    const configPath = getConfigPath(layer, cwd)
    const current = await this.loadRawConfigFile(configPath)

    if (!current) return  // ファイルが存在しない場合は何もしない

    // 設定キーの削除（deleteNestedValue は utils.ts に統合）
    const updated = deleteNestedValue(current, key)
    await this.saveConfigObjectToFile(configPath, updated)
  }

  // 統合テスト用の追加メソッド
  async saveLayer(layer: ConfigLayer, config: Partial<ArereConfig>, cwd: string = this.cwd): Promise<void> {
    const configPath = getConfigPath(layer, cwd)
    await this.saveConfigObjectToFile(configPath, config)
  }

  // Private helpers
  private async saveConfigObjectToFile(configPath: string, config: Partial<ArereConfig>): Promise<void> {
    await mkdir(dirname(configPath), { recursive: true })
    await writeFile(configPath, JSON.stringify(config, null, 2), 'utf-8')
  }

  private async loadRawConfigFile(path: string): Promise<Record<string, unknown> | null> {
    if (!existsSync(path)) return null
    const content = await readFile(path, 'utf-8')
    return JSON.parse(content)
  }
}

// src/infrastructure/plugin/detector.ts
export async function detectPlugins(): Promise<string[]> {
  // npm経由でインストールされたプラグインを検出
  const globalModulesPath = await getGlobalNodeModulesPath()
  const localModulesPath = join(process.cwd(), 'node_modules')

  const plugins: string[] = []

  for (const modulesPath of [globalModulesPath, localModulesPath]) {
    if (!existsSync(modulesPath)) continue

    const dirs = readdirSync(modulesPath)
    const pluginDirs = dirs.filter(dir => dir.startsWith('arere-plugin-'))
    plugins.push(...pluginDirs)
  }

  return [...new Set(plugins)]  // 重複削除
}
```

### 4. Application層

**責務**:
- Domain層とInfrastructure層の調整
- ビジネスワークフローの実行
- 副作用のオーケストレーション

**Simple Instantiation (DI廃止)**:
- FileConfigManager を内部で生成（シンプルなAPI）
- テストでは FileConfigManager をモック
- Single Source of Truth の維持

**実装例**:
```typescript
// src/application/services/ConfigService.ts (統合Manager使用)
export class ConfigService {
  private manager: FileConfigManager

  constructor(cwd?: string) {
    this.manager = new FileConfigManager(cwd)
  }

  /**
   * 設定を変更し、副作用を適用し、ファイルに保存する
   */
  async changeConfig(
    key: string,
    value: unknown,
    layer: ConfigLayer = 'workspace',
    cwd?: string
  ): Promise<ArereConfig> {
    // 1. 副作用を適用
    await this.applySideEffects(key, value)

    // 2. ファイルに保存
    await this.manager.save(layer, key, value, cwd)

    // 3. ファイルから再読み込み（正しいマージ結果を取得）
    const newConfig = await this.manager.loadMerged(cwd)

    return newConfig
  }

  /**
   * 設定値をリセット（キーを削除）
   */
  async resetConfig(
    key: string,
    layer: ConfigLayer = 'workspace',
    cwd?: string
  ): Promise<ArereConfig> {
    await this.writer.delete(layer, key, cwd)
    return await this.repository.getMerged(cwd)
  }

  /**
   * 現在の設定を取得
   */
  async getConfig(cwd?: string): Promise<ArereConfig> {
    return await this.repository.getMerged(cwd)
  }

  private async applySideEffects(key: string, value: unknown): Promise<void> {
    if (key === 'locale') {
      await changeLocale(value as string)
    } else if (key === 'logLevel') {
      setLogLevel(value as LogLevel)
    }
  }
}

// src/application/services/PluginService.ts
export class PluginService {
  /**
   * プラグインの有効/無効を切り替え、設定を保存する
   */
  async togglePlugin(
    currentPlugins: LoadedPlugin[],
    currentConfig: ArereConfig,
    plugin: LoadedPlugin,
    enabled: boolean,
    layer: ConfigLayer
  ): Promise<{ plugins: LoadedPlugin[]; config: ArereConfig }> {
    // 1. プラグインリストを更新
    const newPlugins = currentPlugins.map(p =>
      p.meta.name === plugin.meta.name ? { ...p, enabled } : p
    )

    // 2. 設定オブジェクトを更新
    const newConfig = {
      ...currentConfig,
      plugins: {
        ...currentConfig.plugins,
        [plugin.meta.name]: { enabled },
      },
    }

    // 3. ファイルに保存（FileConfigManager を使用）
    const manager = new FileConfigManager()
    await manager.save(layer, `plugins.${plugin.meta.name}.enabled`, enabled)

    return { plugins: newPlugins, config: newConfig }
  }
}
```

### 5. Presentation層

**責務**:
- ユーザーとのやり取り
- 状態管理（React State）
- Application層の呼び出し

**実装例**:
```typescript
// src/presentation/ui/hooks/app/useConfigManagement.ts
export function useConfigManagement({
  currentConfig,
  setCurrentConfig,
  reloadLayerConfigs,
  setScreen,
}: UseConfigManagementProps) {
  // Application層サービスのインスタンス化（Simple Instantiation）
  const configService = useMemo(() => {
    return new ConfigService()
  }, [])

  const handleConfigChange = useCallback(async (
    key: string,
    value: unknown,
    layer: ConfigLayer = 'workspace'
  ) => {
    try {
      // Application層を呼び出すのみ
      // currentConfig パラメータ削除（Repository が正しい値を返す）
      const newConfig = await configService.changeConfig(key, value, layer)

      // UI状態を更新
      setCurrentConfig(newConfig)

      // レイヤー別設定も再読み込み
      await reloadLayerConfigs()
    } catch (error) {
      logger.error('Failed to change config', error)
    }
  }, [configService, setCurrentConfig, reloadLayerConfigs])

  const handleConfigReset = useCallback(async (
    key: string,
    layer: ConfigLayer = 'workspace'
  ) => {
    try {
      const newConfig = await configService.resetConfig(key, layer)
      setCurrentConfig(newConfig)
      await reloadLayerConfigs()
    } catch (error) {
      logger.error('Failed to reset config', error)
    }
  }, [configService, setCurrentConfig, reloadLayerConfigs])

  return { handleConfigChange, handleConfigReset, handlePluginConfigRequest }
}

// src/presentation/modes/ui-mode.tsx
export class UIMode {
  async run(config: ArereConfig, actions: Action[]): Promise<void> {
    const { render } = await import('ink')
    const React = await import('react')

    // React/Ink UIをレンダリング
    const { waitUntilExit } = render(
      React.createElement(App, { initialConfig: config, initialActions: actions })
    )

    await waitUntilExit()
  }
}
```

### 6. Shared層

**責務**:
- 全層で使用可能な共通ユーティリティ

**実装例**:
```typescript
// src/shared/utils/logger.ts
import pino from 'pino'

let logger = pino({
  level: 'info',
  transport: {
    target: 'pino-pretty',
    options: {
      colorize: true,
      translateTime: 'HH:MM:ss',
      ignore: 'pid,hostname',
    },
  },
})

export function setLogLevel(level: LogLevel): void {
  logger.level = level
}

export { logger }
```

---

## Path Alias システム

### Path Alias 設定

```typescript
// tsconfig.json
{
  "compilerOptions": {
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}

// vitest.config.ts
export default defineConfig({
  resolve: {
    alias: {
      '@': resolve(__dirname, './src'),
    },
  },
})
```

### Import例

```typescript
// ✅ Path alias使用（推奨）
import { logger } from '@/shared/utils/logger.js'
import { ConfigService } from '@/application/services/ConfigService.js'
import type { Action } from '@/domain/action/types.js'
import { FileConfigManager } from '@/infrastructure/config/manager.js'  // 統合Manager
import { mergeConfigs } from '@/infrastructure/config/utils.js'         // 

// ❌ 相対パス（非推奨）
import { logger } from '../../../shared/utils/logger.js'
```

---

## データフロー

### 設定変更のフロー (Unified Manager Pattern)

```
User: Settings画面でlocaleを変更
  ↓
Settings.tsx (Presentation)
  ↓
useConfigManagement.handleConfigChange() (Presentation)
  ↓
ConfigService.changeConfig() (Application)
  ├─→ applySideEffects()
  │    ├─→ changeLocale() (Infrastructure - i18n)
  │    └─→ setLogLevel() (Shared - logger)
  │
  ├─→ manager.save() (Infrastructure - FileConfigManager)
  │    └─→ writeFile() (Node.js fs)
  │
  └─→ manager.loadMerged() (Infrastructure - FileConfigManager)
       └─→ 正しいマージ結果を取得（workspace > user > defaults）
  ↓
newConfig を返す
  ↓
setCurrentConfig(newConfig) (Presentation)
reloadLayerConfigs() (Presentation)
  ↓
UIが再レンダリング（React state更新）
```

**重要な変更点**:
- ✅ **Single Source of Truth**: マージロジックは Manager.loadMerged() のみ
- ✅ **正しい優先順位**: ファイルから再読み込みするため、常に正しい優先順位が反映される
- ✅ **シンプルなAPI**: DI不要で直感的なインスタンス化

### プラグイントグルのフロー

```
User: Settings画面でプラグインをトグル
  ↓
PluginRow.tsx (Presentation)
  ↓
usePluginManagement.handlePluginToggle() (Presentation)
  ↓
PluginService.togglePlugin() (Application)
  ├─→ プラグインリスト更新（pure operation）
  ├─→ 設定オブジェクト更新（pure operation）
  └─→ savePartialConfig() (Infrastructure)
  ↓
{ plugins, config } を返す
  ↓
setCurrentPlugins(plugins) (Presentation)
setCurrentConfig(config) (Presentation)
  ↓
onPluginReload(config) (Presentation)
  └─→ loadActions() (Core)
      └─→ setCurrentActions(actions)
  ↓
UIが再レンダリング
```

---

## テスト戦略

このプロジェクトは**テスト駆動開発（TDD）** を採用しています。

詳細なテストパターンとモック戦略については、[テストガイド](/ja/4.development/2.testing-guide)を参照してください。

### テスト方針概要

**各層のアプローチ**:
- **Core層**: 実ファイルを使った統合テスト
- **Domain層**: 純粋関数の単体テスト（モック不要）
- **Infrastructure層**: 一時ディレクトリでのI/Oテスト
- **Application層**: Infrastructure層をモックしたワークフローテスト
- **Presentation層**: `ink-testing-library` を使ったUIテスト

### カバレッジ目標

層別カバレッジ目標:
- Core層: 90%+
- Domain層: 95%+
- Infrastructure層: 85%+
- Application層: 95%+
- Presentation層: 80%+
- Shared層: 100%

---

## メリット

### 1. テスタビリティの向上
- Application層の分離により、テストが容易
- 各層を独立してテスト可能
- モックが容易

### 2. 保守性の向上
- 各層の責務が明確
- ディレクトリ構造で役割がわかる
- 新機能追加が容易

### 3. 可読性の向上
- Path alias (`@/*`) で import が簡潔
- ファイルの役割が明確
- ディレクトリ構造が直感的

### 4. ビルドの安定性
- TypeScript型チェックによる静的検証
- 明確な依存関係
- ビルドエラーの早期発見

---

## 拡張方針

### 実装済みパターン

1. ✅ **Unified Manager Pattern**
   - Read/Write操作を1つのクラスに統合（FileConfigManager）
   - DI不要でシンプルなAPI
   - Single Source of Truth の維持

2. ✅ **アーキテクチャ簡素化**
   - **第1段階**: Infrastructure/Config層: 14ファイル → 9ファイル (-36%)
     - 後方互換性ラッパー（loader.ts, partial-save.ts）の廃止
     - ファイル統合:
       - `defaults.ts` → `schema.ts` に統合
       - `nested-value.ts` + `merge.ts` → `utils.ts` に統合
       - `writer.ts` → `file-writer.ts` に統合
   - **第2段階**: Infrastructure/Config層: 9ファイル → 6ファイル (-33%)
     - Repository/Writer分離の廃止 → FileConfigManager統合
     - DIパターンの削除（より直感的なAPI）
     - 型安全性の向上（`@ts-expect-error` の削除）
     - 全テスト維持（780 tests pass）

### 将来的な拡張オプション

1. **Context導入**: Propsドリリング解消が必要になった場合
2. **Domain層の拡張**: 複雑なビジネスロジックが増えた場合
3. **Use Cases層**: 複雑なワークフローが増えた場合
4. **DI Container**: コンストラクタ注入の管理が複雑になった場合

### YAGNI原則の遵守

**現在は不要**:
- ❌ 複雑な抽象クラス
- ❌ Use Cases層（Serviceで十分）
- ❌ DI Container（useMemoで十分）

**必要になったら追加**:
- ✅ シンプルに保つ
- ✅ 実際の問題が発生してから対処
- ✅ 過度な抽象化を避ける

**追加済み（実際の問題に対応）**:
- ✅ Unified Manager Pattern（シンプルなAPI、保守性向上）
- ✅ アーキテクチャ簡素化（技術的負債の解消、ファイル数削減）

---

## 参考ドキュメント

- `context-design.md` - React Context設計
- `CLAUDE.md` - プロジェクト全体のアーキテクチャ概要
