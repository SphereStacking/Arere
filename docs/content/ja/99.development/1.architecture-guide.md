---
title: アーキテクチャガイド
description: ArereのFeature-basedアーキテクチャ設計と実装ガイド
---

# アーキテクチャガイド

## 概要

Arereプロジェクトは、関連するコードを技術的なレイヤーではなく**機能ごとにグループ化するFeature-basedアーキテクチャ**を採用しています。

**設計原則**:
- 関連するコードをまとめる（型、ロジック、ユーティリティ）
- ファイルを見つけやすく - 「Xはどこにある？」
- 機能間の依存を最小化
- シンプルで直感的に

---

## ディレクトリ構造

```
src/
├── cli.ts                # CLIエントリーポイント
├── index.ts              # ライブラリAPI公開
│
├── action/               # Action機能
│   ├── types.ts          # Action, ActionContext, ActionMeta 型
│   ├── define.ts         # defineAction() ヘルパー
│   ├── context.ts        # createActionContext()
│   ├── executor.ts       # runAction()
│   ├── loader.ts         # jitiによる動的読み込み
│   ├── registry.ts       # ActionRegistry（last-wins）
│   ├── resolver.ts       # Actionパス解決
│   ├── cache.ts          # Actionキャッシュ
│   └── args/             # CLI引数処理
│       ├── parser.ts
│       ├── validator.ts
│       └── prompt-wrapper.ts
│
├── plugin/               # プラグイン機能
│   ├── types.ts          # ArerePlugin, PluginMeta, LoadedPlugin
│   ├── define.ts         # definePlugin() ヘルパー
│   ├── manager.ts        # PluginManager
│   ├── detector.ts       # プラグイン検出（npmパッケージ）
│   ├── loader.ts         # jitiによるプラグイン読み込み
│   ├── resolver.ts       # プラグインパス解決
│   ├── service.ts        # PluginService（有効/無効切り替え）
│   └── index.ts          # 公開エクスポート
│
├── config/               # 設定管理
│   ├── schema.ts         # Zodスキーマ + defaultConfig
│   ├── manager.ts        # FileConfigManager（読み書き）
│   ├── service.ts        # ConfigService（副作用）
│   ├── paths.ts          # 設定ファイルパス解決
│   ├── types.ts          # ConfigLayer 型
│   ├── utils.ts          # マージユーティリティ
│   ├── errors.ts         # 設定専用エラー
│   └── override-detector.ts
│
├── i18n/                 # 国際化
│   ├── index.ts          # initI18n(), t(), registerTranslations()
│   ├── manager.ts        # TranslationManager
│   ├── scoped.ts         # createScopedT()
│   ├── types.ts          # 翻訳キー型
│   └── utils.ts          # 補間ユーティリティ
│
├── shell/                # シェル実行
│   ├── executor.ts       # $ タグ付きテンプレート実行
│   └── index.ts          # 公開エクスポート
│
├── modes/                # 実行モード
│   ├── ui-mode.ts        # インタラクティブTUIモード
│   ├── headless-mode.ts  # CLIモード（arere run）
│   └── types.ts          # モード型
│
├── ui/                   # ターミナルUI（React/Ink）
│   ├── App.tsx           # メインアプリケーション
│   ├── AppContext.tsx    # アプリケーションコンテキスト
│   │
│   ├── screens/          # 画面コンポーネント
│   │   ├── home/
│   │   ├── search/
│   │   ├── execution/
│   │   ├── settings/
│   │   ├── prompt/
│   │   └── help/
│   │
│   ├── components/       # 共有コンポーネント
│   │   ├── Header.tsx
│   │   ├── Footer.tsx
│   │   ├── ActionList.tsx
│   │   ├── inputs/       # 入力コンポーネント
│   │   └── ...
│   │
│   ├── stores/           # Zustandストア
│   │   ├── screenStore.ts
│   │   ├── settingsStore.ts
│   │   ├── executionStore.ts
│   │   └── promptStore.ts
│   │
│   ├── hooks/            # Reactフック
│   │   ├── useActionExecution.ts
│   │   ├── useConfigManagement.ts
│   │   ├── usePluginManagement.ts
│   │   └── ...
│   │
│   ├── prompts/          # プロンプト実装
│   │   ├── renderer.ts
│   │   ├── text.ts
│   │   ├── select.ts
│   │   ├── confirm.ts
│   │   └── form/
│   │
│   ├── output/           # 出力レンダリング
│   │   ├── collector.ts
│   │   └── plain-renderer.ts
│   │
│   ├── keybindings/      # キーバインドシステム
│   │   ├── defaults.ts
│   │   ├── matcher.ts
│   │   └── parser.ts
│   │
│   ├── control/          # ビジュアルフィードバック
│   │   ├── spinner.ts
│   │   ├── progress.ts
│   │   └── timing.ts
│   │
│   └── kaomoji/          # 顔文字
│
└── lib/                  # 共有ユーティリティ
    ├── logger.ts         # pinoベースロガー
    ├── error.ts          # エラーフォーマット
    ├── path.ts           # パスユーティリティ
    └── types.ts          # 共通型
```

---

## 機能モジュール

### Actionモジュール (`action/`)

Actionシステムは、ユーザー定義Actionの読み込み、登録、実行を担当します。

**主要コンポーネント**:
- `defineAction()` - 型安全なAction定義ヘルパー
- `loadAction()` - jitiを使った動的読み込み
- `ActionRegistry` - 「last-wins」セマンティクスのMapベースレジストリ
- `createActionContext()` - 全APIを含む実行コンテキスト作成

**例**:
```typescript
// ユーザーがActionを定義
export default defineAction({
  description: 'あいさつ',
  translations: {
    en: { greeting: 'Hello!' },
    ja: { greeting: 'こんにちは！' }
  },
  async run({ tui, t }) {
    tui.output.info(t('greeting'))
  }
})

// 内部: 読み込みと実行
const action = await loadAction('/path/to/action.ts')
registry.register(action)
const result = await runAction(action)
```

### プラグインモジュール (`plugin/`)

プラグインシステムは、npmベースのプラグインの検出、読み込み、管理を担当します。

**主要コンポーネント**:
- `definePlugin()` - プラグイン定義ヘルパー
- `detectPlugins()` - `arere-plugin-*` パッケージをnode_modulesからスキャン
- `PluginManager` - プラグインライフサイクル管理
- `PluginService` - 有効/無効操作

**プラグインライフサイクル**:
1. **検出**: `node_modules/` から `arere-plugin-*` パッケージをスキャン
2. **読み込み**: jitiでプラグイン定義を読み込み
3. **検証**: ユーザー設定をスキーマで検証
4. **登録**: プラグインi18n登録 + Actionを読み込み
5. **ホットリロード**: 設定UIで有効/無効切り替え

### 設定モジュール (`config/`)

VSCodeスタイルのレイヤード設定による設定管理。

**主要コンポーネント**:
- `FileConfigManager` - 統合された読み書き操作
- `ConfigService` - 副作用（ロケール変更、ログレベル）
- 検証用Zodスキーマ

**レイヤー優先順位**: workspace > user > defaults

**例**:
```typescript
const manager = new FileConfigManager()
const config = await manager.loadMerged()  // マージ済み設定

await manager.save('workspace', 'locale', 'ja')  // .arere/settings.json に保存
```

### i18nモジュール (`i18n/`)

名前空間ベースの翻訳による国際化。

**主要コンポーネント**:
- `TranslationManager` - コア翻訳エンジン
- `createScopedT()` - 名前空間分離された翻訳関数
- `registerTranslations()` - Action/プラグイン用の動的登録

**名前空間**: `common`, `cli`, `ui`, `errors`、およびAction/プラグイン名前空間

### UIモジュール (`ui/`)

ReactとInkで構築されたターミナルUI。

**主要概念**:
- **Screens**: フルスクリーンビュー（home, search, settings など）
- **Stores**: Zustandによる状態管理
- **Hooks**: ビジネスロジック用カスタムフック
- **Prompts**: 2層非同期プロンプトシステム

**画面フロー**:
```
HomeScreen → SearchScreen → ExecutingScreen → SuccessScreen/ErrorScreen
     ↓
SettingsScreen → PluginListScreen → PluginDetailScreen
```

### シェルモジュール (`shell/`)

タグ付きテンプレートリテラルを使ったシェルコマンド実行。

**例**:
```typescript
const result = await $`npm run build`
// 戻り値: { stdout, stderr, exitCode }

// 安全な補間
const name = 'hello world'
const result = await $`echo ${name}`  // 適切にエスケープ
```

---

## パスエイリアス

すべてのインポートは `@/` パスエイリアスを使用:

```typescript
// tsconfig.json
{
  "compilerOptions": {
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}

// 使用例
import { logger } from '@/lib/logger.js'
import { defineAction } from '@/action/define.js'
import type { Action } from '@/action/types.js'
```

---

## データフロー

### Action実行フロー

```
ユーザーがHomeScreenでActionを選択
  ↓
useActionExecution.executeAction()
  ↓
runAction(action) in action/executor.ts
  ├─→ createActionContext()
  │    ├─→ createScopedT() for translations
  │    ├─→ createShellExecutor() for $
  │    └─→ createOutputAPI() for tui.output
  │
  └─→ action.run(context)
       ├─→ tui.prompt.* (キューイング、PromptScreenで解決)
       ├─→ tui.output.* (収集、OutputRendererでレンダリング)
       └─→ $`command` (実行、結果を返す)
  ↓
結果をUIに返却
  ↓
SuccessScreen または ErrorScreen
```

### 設定変更フロー

```
ユーザーがSettingsScreenで設定を変更
  ↓
useConfigManagement.handleConfigChange()
  ↓
ConfigService.changeConfig()
  ├─→ applySideEffects() (locale, logLevel など)
  └─→ manager.save() → writeFile()
  ↓
manager.loadMerged() → 正しいマージ結果を取得
  ↓
setCurrentConfig(newConfig)
  ↓
UIが再レンダリング
```

---

## テスト戦略

詳細なパターンについては[テストガイド](/development/testing-guide)を参照してください。

### テスト構成

```
tests/
├── unit/           # 機能別ユニットテスト
│   ├── action/
│   ├── plugin/
│   ├── config/
│   ├── i18n/
│   └── ui/
├── integration/    # 複数モジュールテスト
└── e2e/           # エンドツーエンドワークフローテスト
```

### カバレッジ目標

- 全体: 90%+
- コアロジック（action, plugin, config）: 95%+
- UIコンポーネント: 85%+

---

## 主要な設計判断

### なぜFeature-basedか？

1. **直感的なナビゲーション**: 「プラグイン読み込みはどこ？」 → `plugin/loader.ts`
2. **認知負荷の軽減**: 関連するコードが一緒に存在
3. **リファクタリングが容易**: 変更が機能内に局所化
4. **シンプルなインポート**: `@/infrastructure/plugin/` ではなく `@/plugin/`

### なぜClean Architectureではないのか？

Arereのようなオフィスツールでは:
- レイヤーは比例したメリットなく複雑さを追加
- ほとんどの「ビジネスロジック」は単純
- 外部依存が限定的（fs、shell）
- レイヤー分離よりも機能の凝集性が重要

### ガイド原則

1. **YAGNI**: 必要になるまで抽象化を追加しない
2. **コロケーション**: 関連するコードをまとめる
3. **シンプルさ**: 「正しい」アーキテクチャよりシンプルな解決策を優先
4. **プラグマティズム**: アーキテクチャはコードのためにあり、逆ではない

---

## 参考

- `CLAUDE.md` - 開発用クイックリファレンス
- [テストガイド](/development/testing-guide) - テストパターンと戦略
