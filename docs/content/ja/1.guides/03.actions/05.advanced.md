---
title: 高度なテクニック
description: 進捗表示、CI/CD向けアクション、国際化などを学びます
---

# 高度なテクニック

## 進捗表示とフィードバック

長時間実行するアクションでは、進捗表示やフィードバックを提供すると、ユーザーエクスペリエンスが向上します。

### スピナー表示

処理中であることを示すスピナーを表示できます：

```typescript
// ~/.arere/install-deps.ts
import { defineAction } from 'arere'

export default defineAction({
  name: 'install-deps',
  description: '依存パッケージをインストール',
  async run({ tui, $ }) {
    const spinner = tui.control.spinner({ message: 'パッケージをインストール中...' })
    spinner.start()

    const result = await $`npm install`
    if (result.exitCode === 0) {
      spinner.succeed('インストール完了！')
    } else {
      spinner.fail('インストールに失敗しました')
      throw new Error(result.stderr)
    }
  }
})
```

スピナーのメッセージは動的に更新できます：

```typescript
const spinner = tui.control.spinner({ message: 'ステップ 1/3...' })
spinner.start()

await step1()
spinner.update('ステップ 2/3...')

await step2()
spinner.update('ステップ 3/3...')

await step3()
spinner.succeed('すべて完了！')
```

### プログレスバー

進捗率がわかる処理では、プログレスバーが便利です：

```typescript
// ~/.arere/batch-process.ts
import { defineAction } from 'arere'

export default defineAction({
  name: 'batch-process',
  description: 'ファイルをバッチ処理',
  async run({ tui, $ }) {
    const files = ['file1.txt', 'file2.txt', 'file3.txt', 'file4.txt', 'file5.txt']

    const progress = tui.control.progress({
      total: files.length,
      message: 'ファイルを処理中...'
    })

    progress.start()

    for (const file of files) {
      await $`process ${file}`
      progress.increment()  // 1ずつ進める
    }

    progress.succeed('全ファイルの処理が完了しました！')
  }
})
```

進捗を直接設定することもできます：

```typescript
const progress = tui.control.progress({ total: 100 })
progress.start()

for (let i = 0; i <= 100; i += 10) {
  await doWork(i)
  progress.update(i)  // 0, 10, 20, ..., 100
}

progress.succeed('完了！')
```

### 待機とタイミング制御

処理の間に遅延を入れたり、ユーザーの入力を待つことができます：

```typescript
// ~/.arere/demo.ts
import { defineAction } from 'arere'

export default defineAction({
  name: 'demo',
  description: 'デモアクション',
  async run({ tui }) {
    tui.output.info('ステップ 1')
    await tui.control.delay(1000)  // 1秒待機

    tui.output.info('ステップ 2')
    await tui.control.delay(1000)

    tui.output.info('完了しました！')

    // Enterキーを待つ
    await tui.control.waitForEnter('Enterキーを押してください...')
  }
})
```

詳細は [TUI Control API](/api/tui-control) を参照してください。

---

## CI/CD向けアクション

CI/CD環境で実行するアクションを作成する際の考慮事項です。

### ヘッドレスモード対応

CI/CD環境では、UIが表示されないヘッドレスモードで実行されます。アクションは両方のモードで動作するように設計する必要があります。

#### Spinner/Progress の自動フォールバック

**朗報:** `spinner()` と `progress()` はヘッドレスモードでも自動的に動作します！何もしないno-op実装を返すため、`isInteractive()` をチェックする必要はありません：

```typescript
import { defineAction } from 'arere'

export default defineAction({
  name: 'deploy',
  description: 'デプロイを実行',
  async run({ tui, $ }) {
    // TUIでもヘッドレスモードでも動作します！
    const spinner = tui.control.spinner({ message: 'デプロイ中...' })
    spinner.start()
    await $`npm run deploy`
    spinner.succeed('デプロイ完了！')
    // ヘッドレスモードでは: 視覚的な出力はありませんが、エラーも発生しません
  }
})
```

#### モードごとのカスタム動作

各モードで異なる動作が必要な場合は、`isInteractive()` をチェックします：

```typescript
import { defineAction } from 'arere'

export default defineAction({
  name: 'deploy',
  description: 'デプロイを実行',
  async run({ tui, $ }) {
    // インタラクティブ環境かチェック
    if (tui.control.isInteractive()) {
      // TUI環境: リッチなフィードバック
      const spinner = tui.control.spinner({ message: 'デプロイ中...' })
      spinner.start()
      await $`npm run deploy`
      spinner.succeed('デプロイ完了！')
    } else {
      // CI/CD環境: カスタム出力
      tui.output.log('デプロイ中...')
      await $`npm run deploy`
      tui.output.success('デプロイ完了！')
    }
  }
})
```

### CLI引数

`arere run` 経由で実行する際、アクションはコマンドライン引数を受け取れます：

```bash
arere run deploy production --force --verbose
```

```typescript
import { defineAction } from 'arere'

export default defineAction({
  name: 'deploy',
  description: 'ターゲット環境にデプロイ',
  async run({ args, tui, $ }) {
    // args = ['production', '--force', '--verbose']
    const target = args[0] || 'staging'
    const force = args.includes('--force')
    const verbose = args.includes('--verbose')

    if (verbose) {
      tui.output.info(`ターゲット: ${target}`)
      tui.output.info(`強制モード: ${force}`)
    }

    const forceFlag = force ? '--force' : ''
    await $`npm run deploy -- --env ${target} ${forceFlag}`

    tui.output.success(`${target} にデプロイ完了！`)
  }
})
```

::alert{type="info"}
TUI（インタラクティブモード）から実行する場合、`args` は空の配列 `[]` になります。適切なデフォルト値を設定するか、フォールバックとしてプロンプトを使用してください。
::

#### 引数とプロンプトの組み合わせ（手動方式）

```typescript
import { defineAction } from 'arere'

export default defineAction({
  name: 'release',
  description: 'リリースを作成',
  async run({ args, tui, $ }) {
    // CLI引数があれば使用、なければプロンプト
    let version = args[0]
    if (!version) {
      version = await tui.prompt.text('バージョン番号:', {
        placeholder: '1.0.0',
        validate: v => /^\d+\.\d+\.\d+$/.test(v) || '不正なバージョン形式です'
      })
    }

    const dryRun = args.includes('--dry-run')

    if (dryRun) {
      tui.output.info(`[ドライラン] バージョン ${version} をリリース予定`)
      return
    }

    await $`npm version ${version}`
    await $`git push --follow-tags`
    tui.output.success(`バージョン ${version} をリリースしました！`)
  }
})
```

使用例:
```bash
# 引数あり（非インタラクティブ）
arere run release 1.2.3
arere run release 1.2.3 --dry-run

# 引数なし（インタラクティブ）
arere run release
# → バージョンを入力するプロンプトが表示される
```

### 引数マッピング（推奨）

CLI引数とインタラクティブプロンプトの両方をサポートするには、**引数マッピング**を使用するのがよりクリーンな方法です。どのCLI引数がどのプロンプトにマッピングされるかを指定でき、arereは引数が提供されていれば自動的にその値を使用し、そうでなければインタラクティブプロンプトを表示します。

#### 基本的な使い方

```typescript
import { defineAction } from 'arere'

export default defineAction({
  name: 'deploy',
  description: 'アプリケーションをデプロイ',
  async run({ tui, $ }) {
    // --target または -t が指定されていれば使用、なければプロンプト表示
    const target = await tui.prompt.select(
      'デプロイ先',
      ['staging', 'production'],
      {
        arg: 'target',        // --target=production
        argShort: 't',        // -t production
        description: 'デプロイ先の環境',
      }
    )

    // --yes または -y が指定されていれば確認をスキップ
    const confirmed = await tui.prompt.confirm(
      'この環境にデプロイしますか？',
      {
        arg: 'yes',           // --yes
        argShort: 'y',        // -y
        description: '確認をスキップ',
      }
    )

    if (!confirmed) return

    await $`deploy --env=${target}`
    tui.output.success(`${target} にデプロイしました！`)
  }
})
```

使用例:
```bash
# 完全にインタラクティブ
arere run deploy

# 一部指定（残りはプロンプト表示）
arere run deploy --target=staging

# 完全にヘッドレス（CI/CD）
arere run deploy --target=production --yes

# 短い形式のフラグ
arere run deploy -t production -y

# 利用可能な引数を表示
arere run deploy --help
```

#### 引数マッピングオプション

すべてのプロンプトメソッドで以下のマッピングオプションがサポートされています：

| オプション | 型 | 説明 |
|--------|------|-------------|
| `arg` | `string` | 長い引数名（例：`--target` の `'target'`） |
| `argShort` | `string` | 短い引数名（例：`-t` の `'t'`） |
| `argIndex` | `number` | 位置引数のインデックス（0から開始） |
| `description` | `string` | `--help` 出力に表示される説明 |

#### すべてのプロンプトタイプの例

```typescript
import { defineAction } from 'arere'

export default defineAction({
  name: 'release',
  description: 'リリースを作成',
  async run({ tui, $ }) {
    // テキスト入力: --version または最初の位置引数
    const version = await tui.prompt.text('バージョン', {
      arg: 'version',
      argIndex: 0,
      description: 'リリースバージョン（例：1.0.0）',
      validate: v => /^\d+\.\d+\.\d+$/.test(v) || '無効なsemver形式',
    })

    // 数値入力: --port
    const port = await tui.prompt.number('ポート', {
      arg: 'port',
      argShort: 'p',
      description: 'サーバーポート',
      min: 1024,
      max: 65535,
      defaultValue: 3000,
    })

    // 選択: --env
    const env = await tui.prompt.select('環境', ['dev', 'staging', 'prod'], {
      arg: 'env',
      argShort: 'e',
      description: '対象環境',
    })

    // 確認: --yes（フラグ）
    const confirmed = await tui.prompt.confirm('続行しますか？', {
      arg: 'yes',
      argShort: 'y',
      description: '確認をスキップ',
    })

    // 複数選択: --features（カンマ区切り）
    const features = await tui.prompt.multiSelect(
      '機能',
      ['api', 'web', 'mobile', 'docs'],
      {
        arg: 'features',
        argShort: 'f',
        description: '含める機能（カンマ区切り）',
      }
    )

    // パスワード: --token
    const token = await tui.prompt.password('APIトークン', {
      arg: 'token',
      description: 'API認証トークン',
    })

    tui.output.info(`${env} に ${version} をリリース中`)
    tui.output.info(`ポート: ${port}`)
    tui.output.info(`機能: ${features.join(', ')}`)
    // ... リリース実行
  }
})
```

CLI使用例:
```bash
# 完全ヘッドレスモード
arere run release 1.2.0 \
  --port=8080 \
  --env=prod \
  --yes \
  --features=api,web \
  --token=secret123

# 混合モード
arere run release --env=staging
# → バージョン、ポート、機能などはプロンプト表示
```

#### 引数フォーマットリファレンス

```bash
# 長い引数
--name=value         # = 区切り
--name value         # スペース区切り

# 短い引数
-n=value             # = 区切り
-nvalue              # インライン値

# フラグ（confirmプロンプト用）
--yes                # true
-y                   # true
--yes=true           # true
--yes=false          # false

# 位置引数（インデックス指定）
arere run deploy staging  # args[0] = 'staging'

# 複数選択（カンマ区切り）
--features=a,b,c
```

#### ヘルプ表示

引数マッピングを使用している場合、ユーザーは `--help` で利用可能な引数を確認できます：

```bash
$ arere run deploy --help

deploy - アプリケーションをデプロイ

Options:
  -t, --target <staging|production>  デプロイ先の環境
  -y, --yes                          確認をスキップ

Usage:
  arere run deploy [options]
```

::alert{type="tip"}
より良いヘルプ出力のために、引数マッピングには必ず `description` を追加してください。
::

#### 非インタラクティブモードの動作

非インタラクティブモード（CI/CD）では、引数マッピングを持つプロンプトは以下のように動作します：
1. CLI引数の値が指定されていれば使用
2. 引数が指定されておらず `defaultValue` があれば使用
3. 必須で値がない場合はエラーをスロー

```typescript
// CI環境で --name が指定されていない場合エラー
const name = await tui.prompt.text('名前', { arg: 'name' })

// CI環境で --name が指定されていない場合デフォルト値を使用
const name = await tui.prompt.text('名前', {
  arg: 'name',
  defaultValue: 'anonymous',
})
```

### 環境変数の使用

CI/CD環境では、設定やシークレットは環境変数から読み取ります：

```typescript
import { defineAction } from 'arere'

export default defineAction({
  name: 'deploy',
  description: 'プロダクションにデプロイ',
  async run({ env, $ }) {
    // 必須の環境変数をチェック
    if (!env.API_KEY) {
      throw new Error('API_KEY environment variable is required')
    }

    if (!env.DEPLOY_URL) {
      throw new Error('DEPLOY_URL environment variable is required')
    }

    // 環境変数を使用
    await $`curl -X POST ${env.DEPLOY_URL} -H "Authorization: Bearer ${env.API_KEY}"`
  }
})
```

### エラーハンドリング

CI/CD環境では、適切な終了コードを返すことが重要です：

```typescript
import { defineAction } from 'arere'

export default defineAction({
  name: 'test',
  description: 'テストを実行',
  async run({ $, tui }) {
    // テスト実行
    const result = await $`npm test`

    if (result.exitCode !== 0) {
      tui.output.error('テストが失敗しました')
      tui.output.code(result.stderr)
      // プロセスを非ゼロの終了コードで終了
      throw new Error('Test failed')
    }

    tui.output.success('すべてのテストが成功しました')
  }
})
```

::alert{type="info"}
シェルコマンドはエラーをthrowしません。`result.exitCode` で成功/失敗を判定してください。
::

### GitHub Actionsでの使用例

```yaml
# .github/workflows/test.yml
name: Test

on: [push]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '18'
      - run: npm install arere
      - run: npx arere run test
```

詳細は [GitHub Actions統合ガイド](/guides/github-actions/overview) を参照してください。

---

## 複雑な入力パターン

### 複数の入力を組み合わせる

```typescript
// ~/.arere/create-pr.ts
import { defineAction } from 'arere'

export default defineAction({
  name: 'create-pr',
  description: 'プルリクエストを作成',
  category: 'git',
  async run({ $, tui }) {
    // 1. ブランチ一覧を取得
    const { stdout } = await $`git branch --format=%(refname:short)`
    const branches = stdout.split('\n').filter(Boolean)

    // 2. マージ先ブランチを選択
    const targetBranch = await tui.prompt.select('マージ先のブランチ:', branches)

    // 3. タイトル入力
    const title = await tui.prompt.text('PRタイトル:', {
      validate: v => v.length > 0 || 'タイトルを入力してください',
    })

    // 4. 説明入力
    const description = await tui.prompt.text('PR説明:', {
      placeholder: '変更内容を入力...',
    })

    // 5. レビュアー選択
    const reviewers = await tui.prompt.multiSelect('レビュアーを選択:', [
      'alice',
      'bob',
      'charlie',
    ])

    // 6. ドラフトか確認
    const isDraft = await tui.prompt.confirm('ドラフトPRとして作成しますか？', { defaultValue: false })

    // 7. 確認
    tui.output.section('PR情報')
    tui.output.log(`  タイトル: ${title}`)
    tui.output.log(`  マージ先: ${targetBranch}`)
    tui.output.log(`  レビュアー: ${reviewers.join(', ')}`)
    tui.output.log(`  ドラフト: ${isDraft ? 'Yes' : 'No'}`)

    const confirmed = await tui.prompt.confirm('\nこの内容でPRを作成しますか？', { defaultValue: true })

    if (!confirmed) {
      tui.output.warn('キャンセルしました')
      return
    }

    // 8. PR作成
    const draftFlag = isDraft ? '--draft' : ''
    const reviewerFlags = reviewers.map(r => `--reviewer ${r}`).join(' ')

    await $`gh pr create --title ${title} --body ${description} --base ${targetBranch} ${draftFlag} ${reviewerFlags}`

    tui.output.success('✓ PRを作成しました')
  }
})
```

### 動的なアクション選択

```typescript
// ~/.arere/docker-logs.ts
import { defineAction } from 'arere'

export default defineAction({
  name: 'docker-logs',
  description: 'Docker コンテナのログを表示',
  category: 'docker',
  async run({ $, tui }) {
    // コンテナ一覧を取得
    const { stdout } = await $`docker ps --format {{.Names}}`
    const containers = stdout.split('\n').filter(Boolean)

    if (containers.length === 0) {
      tui.output.warn('実行中のコンテナがありません')
      return
    }

    // コンテナを選択
    const container = await tui.prompt.select('コンテナを選択:', containers)

    // フォローするか確認
    const follow = await tui.prompt.confirm('ログをフォローしますか？', { defaultValue: false })

    // ログ表示
    const followFlag = follow ? '-f' : ''
    await $`docker logs ${container} ${followFlag}`
  }
})
```

### ファイル処理

```typescript
// ~/.arere/create-component.ts
import { defineAction } from 'arere'
import { writeFileSync, mkdirSync } from 'node:fs'
import { join } from 'node:path'

export default defineAction({
  name: 'create-component',
  description: 'React コンポーネントを作成',
  async run({ tui }) {
    // コンポーネント名を入力
    const name = await tui.prompt.text('コンポーネント名:', {
      validate: (v) => {
        if (!/^[A-Z][a-zA-Z0-9]*$/.test(v)) {
          return 'コンポーネント名はパスカルケースで入力してください'
        }
        return true
      },
    })

    // テストファイルも作成するか確認
    const withTest = await tui.prompt.confirm('テストファイルも作成しますか？', { defaultValue: true })

    // ディレクトリ作成
    const dir = join(process.cwd(), 'src', 'components', name)
    mkdirSync(dir, { recursive: true })

    // コンポーネントファイル
    const componentContent = `\
import React from 'react'

export interface ${name}Props {
  // props
}

export const ${name}: React.FC<${name}Props> = (props) => {
  return (
    <div>
      ${name} Component
    </div>
  )
}
`
    writeFileSync(join(dir, `${name}.tsx`), componentContent)

    // テストファイル
    if (withTest) {
      const testContent = `\
import { describe, it, expect } from 'vitest'
import { render } from '@testing-library/react'
import { ${name} } from './${name}'

describe('${name}', () => {
  it('should render', () => {
    const { container } = render(<${name} />)
    expect(container).toBeTruthy()
  })
})
`
      writeFileSync(join(dir, `${name}.test.tsx`), testContent)
    }

    tui.output.success(`✓ コンポーネントを作成しました: ${dir}`)
  }
})
```

---

## 国際化 (i18n)

アクションを多言語対応させることができます。

### translations プロパティを使う

`defineAction()` の `translations` プロパティを使って、アクション内に直接翻訳を埋め込めます：

```typescript
import { defineAction } from 'arere'

export default defineAction({
  name: 'greet',
  description: ({ t }) => t('description'),
  // 翻訳を定義
  translations: {
    en: {
      description: 'Greet someone',
      prompt_name: 'What is your name?',
      greeting: 'Hello, {{name}}!',
      farewell: 'Nice to meet you!'
    },
    ja: {
      description: '挨拶する',
      prompt_name: 'お名前は？',
      greeting: 'こんにちは、{{name}}さん!',
      farewell: 'よろしくお願いします!'
    }
  } as const,  // as const で型推論を有効化
  async run({ t, tui }) {
    // 翻訳されたプロンプトメッセージ
    const name = await tui.prompt.text(t('prompt_name'))

    // 翻訳されたメッセージ（変数埋め込み）
    tui.output.log(t('greeting', { name }))
    tui.output.log(t('farewell'))
  }
})
```

### i18nの利点

1. **単一ファイル**: 翻訳とコードを一緒に管理
2. **型安全**: `as const` により翻訳キーが型チェックされる
3. **シンプル**: 追加のファイル構造不要
4. **ポータブル**: 簡単に共有できる

### 重要なポイント

**1. `as const` を忘れずに**

型推論を有効化するため、translations オブジェクトに `as const` を付けてください：

```typescript
translations: {
  en: { greeting: 'Hello!' },
  ja: { greeting: 'こんにちは!' }
} as const  // ← これが重要！
```

**2. ネームスペース不要**

`translations` プロパティを使う場合、`t()` 関数は自動的にアクションのスコープに制限されるため、`ns` オプションは不要です：

```typescript
// ✅ 正しい
t('greeting')

// ❌ 不要（translations プロパティを使う場合）
t('greeting', { ns: 'my-action' })
```

**3. description での使用**

description でも翻訳キーを使えます：

```typescript
defineAction({
  name: 'greet',
  description: ({ t }) => t('description'),  // translations から取得
  translations: {
    en: { description: 'Greet someone' },
    ja: { description: '挨拶する' }
  } as const,
  // ...
})
```

詳細は [i18nガイド](/guides/i18n-guide) を参照してください。

---

## 次のステップ

- [チュートリアル](/guides/tutorials) - ステップバイステップで学ぶ
- [defineAction API](/api/define-action) - アクション定義の詳細
- [Prompt API](/api/prompt) - ユーザー入力の取得
- [Control API](/api/tui-control) - 進捗表示とタイミング制御
- [Shell Executor](/api/shell) - シェルコマンドの実行
- [GitHub Actions統合](/guides/github-actions/overview) - CI/CDで使う
- [プラグイン開発ガイド](/guides/plugins/creating) - プラグインの作成方法
- [i18nガイド](/guides/i18n-guide) - 国際化の詳細
