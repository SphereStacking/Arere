---
title: TUI Control API
description: ターミナル出力のタイミング、ユーザーインタラクションの一時停止、視覚的フィードバックを細かく制御するためのAPIリファレンス
---

# Control API リファレンス

Control API (`tui.control`) は、ターミナル出力のタイミング、ユーザーインタラクションの一時停止、視覚的フィードバックを細かく制御するためのAPIを提供します。

## 概要

```typescript
const context: ActionContext = {
  tui: {
    control: {
      // タイミング制御
      delay(ms: number): Promise<void>
      waitForEnter(message?: string): Promise<void>
      waitForKey(options?: WaitForKeyOptions): Promise<string>

      // 視覚的フィードバック
      spinner(options?: SpinnerOptions): SpinnerControl
      progress(options?: ProgressOptions): ProgressControl

      // ターミナルユーティリティ
      isInteractive(): boolean
      getTerminalSize(): TerminalSize
    }
  }
}
```

---

## タイミング制御

### `delay(ms)`

指定されたミリ秒数だけ実行を一時停止します。

**パラメータ:**
- `ms` (number): ミリ秒単位の遅延時間

**返り値:** `Promise<void>`

**エラー:** `ms`が負の値の場合にエラーをスロー

**例:**
```typescript
await tui.control.delay(1000)  // 1秒待機
```

**注意:**
- テスト環境（`NODE_ENV=test`または`VITEST=true`）では自動的に遅延をスキップ
- 30秒を超える遅延に対して警告を表示
- Ctrl+Cによるキャンセルを尊重

---

### `waitForEnter(message?)`

ユーザーがEnterキーを押すまで待機します。

**パラメータ:**
- `message` (string, オプション): 待機中に表示するメッセージ

**返り値:** `Promise<void>`

**例:**
```typescript
await tui.control.waitForEnter('Enterキーを押して続行...')
```

**注意:** Inkレンダリングコンテキストが必要です。ヘッドレスモード（Phase 32）では利用できません。

---

### `waitForKey(options?)`

ユーザーが特定のキーまたは任意のキーを押すまで待機します。

**パラメータ:**
- `options` (WaitForKeyOptions, オプション):
  - `keys` (string[], オプション): 受け入れる特定のキー。省略すると任意のキーを受け入れます。
  - `message` (string, オプション): 待機中に表示するメッセージ
  - `timeout` (number, オプション): ミリ秒単位のタイムアウト
  - `caseInsensitive` (boolean, オプション): 大文字小文字を区別しないマッチング（デフォルト: false）

**返り値:** `Promise<string>` - 押されたキー

**例:**
```typescript
// 任意のキーを待つ
const key = await tui.control.waitForKey()

// 特定のキーを待つ
const choice = await tui.control.waitForKey({
  keys: ['y', 'n'],
  message: '続行しますか？ [y/n]',
  caseInsensitive: true
})

if (choice === 'y') {
  // ユーザーが'y'または'Y'を押した
}
```

**注意:** Inkレンダリングコンテキストが必要です。ヘッドレスモード（Phase 32）では利用できません。

---

## 視覚的フィードバック

### `spinner(options?)`

進行中の操作用のスピナーを作成して制御します。

**パラメータ:**
- `options` (SpinnerOptions, オプション):
  - `type` ('dots' | 'line' | 'arc', オプション): スピナーアニメーションタイプ（デフォルト: 'dots'）
  - `message` (string, オプション): 初期メッセージ（デフォルト: 'Loading...'）

**返り値:** `SpinnerControl`オブジェクト（以下のメソッドを持つ）:
- `start()`: スピナーを開始
- `stop()`: スピナーを停止
- `succeed(message?)`: 成功としてマークして停止（1秒後に自動クリア）
- `fail(message?)`: 失敗としてマークして停止（1秒後に自動クリア）
- `update(message)`: スピナーメッセージを更新

**例:**
```typescript
const spinner = tui.control.spinner({
  type: 'dots',
  message: 'データを読み込み中...'
})

spinner.start()

try {
  await fetchData()
  spinner.succeed('データを読み込みました！')
} catch (error) {
  spinner.fail('データの読み込みに失敗しました')
}
```

**高度な例:**
```typescript
const spinner = tui.control.spinner({ message: 'ステップ1...' })
spinner.start()

await step1()
spinner.update('ステップ2...')

await step2()
spinner.update('ステップ3...')

await step3()
spinner.succeed('すべてのステップが完了しました！')
```

**注意:** ヘッドレスモード（CI/CD）では、スピナーは何もしないno-op実装として動作します。エラーは発生せず、視覚的な出力もありません。

---

### `progress(options?)`

既知の合計値を持つ操作用のプログレスバーを作成して制御します。

**パラメータ:**
- `options` (ProgressOptions, オプション):
  - `total` (number, オプション): 合計値（デフォルト: 100）
  - `value` (number, オプション): 初期値（デフォルト: 0）
  - `message` (string, オプション): 初期メッセージ（デフォルト: 'Processing...'）

**返り値:** `ProgressControl`オブジェクト（以下のメソッドを持つ）:
- `start()`: プログレスバーを開始
- `update(value)`: 進捗値を更新（合計値にクランプされる）
- `increment(delta?)`: deltaだけ増加（デフォルト: 1）
- `stop()`: プログレスバーを停止
- `succeed(message?)`: 成功としてマークして停止（1秒後に自動クリア）
- `fail(message?)`: 失敗としてマークして停止（1秒後に自動クリア）

**例:**
```typescript
const progress = tui.control.progress({
  total: 100,
  message: 'ファイルをダウンロード中...'
})

progress.start()

for (let i = 0; i <= 100; i += 10) {
  await downloadChunk(i)
  progress.update(i)
}

progress.succeed('ダウンロード完了！')
```

**インクリメントの例:**
```typescript
const progress = tui.control.progress({
  total: files.length,
  message: 'ファイルを処理中...'
})

progress.start()

for (const file of files) {
  await processFile(file)
  progress.increment()  // 1ずつ増加
}

progress.succeed('すべてのファイルを処理しました！')
```

**注意:** ヘッドレスモード（CI/CD）では、プログレスバーは何もしないno-op実装として動作します。エラーは発生せず、視覚的な出力もありません。

---

## ターミナルユーティリティ

### `isInteractive()`

現在のターミナル環境がインタラクティブかどうかをチェックします。

**返り値:** `boolean` - インタラクティブ（TTY）の場合にtrue

**例:**
```typescript
if (tui.control.isInteractive()) {
  // リッチなUI機能を使用
  const spinner = tui.control.spinner()
  spinner.start()
} else {
  // シンプルな出力にフォールバック
  tui.output.log('処理中...')
}
```

**検出ロジック:**
- TTYでない場合（`!process.stdout.isTTY`）に`false`を返す
- CI環境（`process.env.CI === 'true'`）の場合に`false`を返す
- `NO_COLOR`が設定されている場合に`false`を返す
- `TERM=dumb`の場合に`false`を返す
- それ以外の場合は`true`を返す

---

### `getTerminalSize()`

現在のターミナルの寸法を取得します。

**返り値:** `TerminalSize`オブジェクト:
- `width` (number): 列単位のターミナル幅
- `height` (number): 行単位のターミナル高さ

**例:**
```typescript
const size = tui.control.getTerminalSize()
tui.output.log(`ターミナル: ${size.width}x${size.height}`)

if (size.width < 80) {
  tui.output.warn('ターミナルが狭いため、一部の出力が折り返される可能性があります')
}
```

**デフォルト値:** ターミナルサイズが判定できない場合、`{ width: 80, height: 24 }`を返します。

---

## ベストプラクティス

### 1. ヘッドレスモードでの動作

ヘッドレスモード（CI/CD環境）では、`spinner()` と `progress()` は自動的に**何もしないno-op実装**を返します。これにより、`isInteractive()` をチェックせずに安全に使用できます：

```typescript
// TUIでもヘッドレスモードでも動作します！
const spinner = tui.control.spinner({ message: '処理中...' })
spinner.start()
await operation()
spinner.succeed('完了！')
// ヘッドレスモードでは：視覚的な出力はありませんが、エラーも発生しません
```

各モードで異なる動作が必要な場合は、`isInteractive()` をチェックします：

```typescript
if (tui.control.isInteractive()) {
  const spinner = tui.control.spinner()
  spinner.start()
  await operation()
  spinner.succeed()
} else {
  tui.output.log('操作を実行中...')
  await operation()
  tui.output.success('操作完了')
}
```

### 2. 適切な視覚的フィードバックを使用

- **Spinner**: 期間が不明な操作用
- **Progress**: 既知の合計ステップ数を持つ操作用

### 3. エラーを適切に処理

```typescript
const spinner = tui.control.spinner({ message: '処理中...' })
spinner.start()

try {
  await riskyOperation()
  spinner.succeed('成功！')
} catch (error) {
  spinner.fail('操作に失敗しました')
  throw error
}
```

### 4. 過度な遅延を避ける

```typescript
// ❌ 悪い例: 遅延が多すぎてユーザー体験が遅くなる
await tui.control.delay(1000)
tui.output.log('ステップ1')
await tui.control.delay(1000)
tui.output.log('ステップ2')
await tui.control.delay(1000)

// ✅ 良い例: 重要な操作の前だけ遅延
tui.output.log('ステップ1')
tui.output.log('ステップ2')
await tui.control.delay(500)  // 重要なアクションの前の短い一時停止
await criticalOperation()
```

### 5. Output APIと組み合わせる

```typescript
tui.output.section('デプロイ')

const progress = tui.control.progress({
  total: steps.length,
  message: 'デプロイ中...'
})

progress.start()

for (const step of steps) {
  tui.output.info(`実行中: ${step.name}`)
  await step.run()
  progress.increment()
}

progress.succeed('デプロイ完了！')
tui.output.success('✅ すべて完了！')
```

---

## 関連項目

- [Prompt API](./prompt.md) - ユーザー入力の収集用
- [TUI API](./tui.md) - メッセージの表示用（Output API）
- [Prompt vs Control API ガイド](/api/tui-control) - どのAPIをいつ使うべきか
