---
title: Shell Executor
description: シェルコマンドを実行するためのAPIリファレンス
---

# $ (shell) API

シェルコマンドを実行するためのAPIです。

## インポート

```typescript
// アクション内では context.$ から使用します
```

アクション内では `context.$` から使用できます：

```typescript
export default defineAction({
  async run({ $ }) {
    await $`git status`
  }
})
```

## 構文

```typescript
$`command ${arg1} ${arg2}`
```

テンプレートリテラル形式でコマンドを実行します。変数は自動的にエスケープされます。

## 戻り値

`Promise<ShellResult>` を返します。

### `ShellResult`

| プロパティ | 型 | 説明 |
|-----------|-----|------|
| `stdout` | `string` | 標準出力 |
| `stderr` | `string` | 標準エラー出力 |
| `exitCode` | `number` | 終了コード |
| `command` | `string` | 実行されたコマンド |

## 基本的な使い方

### コマンド実行

```typescript
// 基本的なコマンド
await $`echo Hello, World!`

// 標準出力を取得
const { stdout } = await $`pwd`
tui.output.log('現在のディレクトリ:', stdout)

// 複数のコマンド
await $`mkdir -p tmp/test`
await $`touch tmp/test/file.txt`
await $`ls -la tmp/test`
```

### 変数の展開

```typescript
const fileName = 'test.txt'
const content = 'Hello, World!'

// 変数は自動的にエスケープされる
await $`echo ${content} > ${fileName}`

// 配列を展開
const files = ['file1.txt', 'file2.txt', 'file3.txt']
await $`rm ${files}` // rm file1.txt file2.txt file3.txt

// 数値も使用可能
const port = 3000
await $`lsof -i :${port}`
```

### エラーハンドリング

`$` はエラーをスローしません。代わりに `exitCode` をチェックして結果を判定します：

```typescript
// exitCodeをチェック
const result = await $`git status`
if (result.exitCode !== 0) {
  tui.output.error('Gitリポジトリではありません')
  return
}

// 成功時の処理
tui.output.log(result.stdout)
```

## 実用例

### Git操作

```typescript
// ステータス確認
const { stdout } = await $`git status --short`
tui.output.log(stdout)

// ブランチ一覧
const { stdout: branches } = await $`git branch --format=%(refname:short)`
const branchList = branches.split('\n').filter(Boolean)

// コミット
const message = 'feat: add new feature'
await $`git add .`
await $`git commit -m ${message}`
await $`git push`

// ブランチ切り替え
const branch = 'develop'
await $`git switch ${branch}`

// Gitログ
const { stdout: log } = await $`git log --oneline -n 10`
tui.output.log(log)
```

### Docker操作

```typescript
// コンテナ一覧
const { stdout } = await $`docker ps --format {{.Names}}`
const containers = stdout.split('\n').filter(Boolean)

// イメージビルド
const imageName = 'my-app'
const tag = 'v1.0.0'
await $`docker build -t ${imageName}:${tag} .`

// コンテナ起動
await $`docker-compose up -d`

// ログ確認
const { stdout: logs } = await $`docker logs my-container`
tui.output.log(logs)

// コンテナ停止
await $`docker-compose down`
```

### ファイル操作

```typescript
// ファイル作成
const fileName = 'test.txt'
await $`touch ${fileName}`

// ディレクトリ作成
const dirName = 'my-dir'
await $`mkdir -p ${dirName}`

// ファイルコピー
await $`cp source.txt dest.txt`

// ファイル移動
await $`mv old-name.txt new-name.txt`

// ファイル削除
await $`rm test.txt`

// ディレクトリ削除
await $`rm -rf ${dirName}`

// ファイル内容確認
const { stdout } = await $`cat package.json`
tui.output.log(stdout)
```

### npm/yarn操作

```typescript
// パッケージインストール
const packageName = 'lodash'
await $`npm install ${packageName}`

// アクション実行
await $`npm run build`
await $`npm test`

// パッケージ情報
const { stdout } = await $`npm list --depth=0`
tui.output.log(stdout)

// yarn の場合
await $`yarn add ${packageName}`
await $`yarn build`
```

### システム情報

```typescript
// OS情報
const { stdout: os } = await $`uname -a`
tui.output.log('OS:', os)

// ディスク使用量
const { stdout: disk } = await $`df -h`
tui.output.log(disk)

// メモリ使用量
const { stdout: mem } = await $`free -h`
tui.output.log(mem)

// プロセス確認
const { stdout: processes } = await $`ps aux | grep node`
tui.output.log(processes)
```

## 高度な使い方

### パイプライン

```typescript
// パイプを使った複雑なコマンド
const { stdout } = await $`cat package.json | grep version | head -n 1`
tui.output.log(stdout)

// grepで検索
const searchTerm = 'TODO'
const { stdout: searchResult } = await $`grep -r ${searchTerm} src/`
tui.output.log(searchResult)
```

### 条件分岐

```typescript
// ファイルの存在確認
const fileName = 'test.txt'
const { exitCode } = await $`test -f ${fileName}`

if (exitCode === 0) {
  tui.output.log('ファイルが存在します')
} else {
  tui.output.log('ファイルが存在しません')
}

// ディレクトリの存在確認
const dirName = 'src'
const { exitCode: dirExists } = await $`test -d ${dirName}`

if (dirExists === 0) {
  tui.output.log('ディレクトリが存在します')
}
```

### バックグラウンド実行

```typescript
// サーバーをバックグラウンドで起動
const server = $`npm run dev`

// 少し待つ
await new Promise(resolve => setTimeout(resolve, 2000))

// テスト実行
await $`npm test`

// サーバー停止
server.kill()
```

### 標準入力へのデータ送信

```typescript
// コマンドに入力を渡す
const input = 'Hello\nWorld\n'
const result = await $({ input })`cat`
console.log(result.stdout) // "Hello\nWorld"
```

## 注意点

### セキュリティ

変数は自動的にエスケープされますが、信頼できないユーザー入力を実行する場合は注意が必要です：

```typescript
// ✅ 安全 - 変数は自動エスケープ
const userInput = "test; rm -rf /"
await $`echo ${userInput}` // "test; rm -rf /" がそのまま出力される

// ❌ 危険 - 文字列連結は使わない
await $`echo ${userInput}` // インジェクション攻撃の可能性
```

### エラーハンドリング

`$` はエラーをスローしません。`exitCode` をチェックして結果を判定してください：

```typescript
const result = await $`nonexistent-command`
if (result.exitCode !== 0) {
  tui.output.error('コマンドが失敗しました:', result.stderr)
}
```

### 終了コードの確認

```typescript
// 終了コードをチェック
const result = await $`command-that-might-fail`
tui.output.log('終了コード:', result.exitCode)

// 成功時のみ処理を継続
const { exitCode, stdout } = await $`git status`
if (exitCode === 0) {
  tui.output.log(stdout)
}
```

## オプション

シェルエクセキュータは内部的に Node.js の `spawn` を使用しています。

```typescript
// カレントディレクトリを指定
await $({ cwd: '/path/to/dir' })`ls`

// 環境変数を追加
await $({ env: { NODE_ENV: 'production' } })`npm run build`

// タイムアウト設定
await $({ timeout: 5000 })`long-running-command`

// シェルを指定
await $({ shell: true })`echo $HOME`
```

## 型定義

```typescript
interface ShellExecutor {
  (strings: TemplateStringsArray, ...values: unknown[]): Promise<ShellResult>
  (options: ExecaOptions): (strings: TemplateStringsArray, ...values: unknown[]) => Promise<ShellResult>
}

interface ShellResult {
  stdout: string
  stderr: string
  exitCode: number
  command: string
}
```

## 参照

- [defineAction API](./defineAction.md)
- [prompt API](./prompt.md)
- [アクション作成チュートリアル](../ja/guides/creating-actions.md)
