---
title: Advanced Techniques
description: Learn progress display, CI/CD actions, internationalization, and more
---

# Advanced Techniques

## Progress Display and Feedback

For long-running actions, providing progress display and feedback improves user experience.

### Spinner Display

You can display a spinner to indicate processing:

```typescript
// ~/.arere/install-deps.ts
import { defineAction } from 'arere'

export default defineAction({
  name: 'install-deps',
  description: 'Install dependency packages',
  async run({ tui, $ }) {
    const spinner = tui.control.spinner({ message: 'Installing packages...' })
    spinner.start()

    const result = await $`npm install`
    if (result.exitCode === 0) {
      spinner.succeed('Installation complete!')
    } else {
      spinner.fail('Installation failed')
      throw new Error(result.stderr)
    }
  }
})
```

Spinner messages can be updated dynamically:

```typescript
const spinner = tui.control.spinner({ message: 'Step 1/3...' })
spinner.start()

await step1()
spinner.update('Step 2/3...')

await step2()
spinner.update('Step 3/3...')

await step3()
spinner.succeed('All done!')
```

### Progress Bar

For processes where you know the progress percentage, a progress bar is useful:

```typescript
// ~/.arere/batch-process.ts
import { defineAction } from 'arere'

export default defineAction({
  name: 'batch-process',
  description: 'Batch process files',
  async run({ tui, $ }) {
    const files = ['file1.txt', 'file2.txt', 'file3.txt', 'file4.txt', 'file5.txt']

    const progress = tui.control.progress({
      total: files.length,
      message: 'Processing files...'
    })

    progress.start()

    for (const file of files) {
      await $`process ${file}`
      progress.increment()  // Increment by 1
    }

    progress.succeed('All files processed!')
  }
})
```

You can also set progress directly:

```typescript
const progress = tui.control.progress({ total: 100 })
progress.start()

for (let i = 0; i <= 100; i += 10) {
  await doWork(i)
  progress.update(i)  // 0, 10, 20, ..., 100
}

progress.succeed('Complete!')
```

### Waiting and Timing Control

You can add delays between processes or wait for user input:

```typescript
// ~/.arere/demo.ts
import { defineAction } from 'arere'

export default defineAction({
  name: 'demo',
  description: 'Demo action',
  async run({ tui }) {
    tui.output.info('Step 1')
    await tui.control.delay(1000)  // Wait 1 second

    tui.output.info('Step 2')
    await tui.control.delay(1000)

    tui.output.info('Complete!')

    // Wait for Enter key
    await tui.control.waitForEnter('Press Enter to continue...')
  }
})
```

See [TUI Control API](/en/api/tui-control) for details.

---

## CI/CD Actions

Considerations when creating actions for CI/CD environments.

### Headless Mode Support

In CI/CD environments, actions run in headless mode without UI display. Actions should be designed to work in both modes.

#### Detecting Interactive Mode

```typescript
import { defineAction } from 'arere'

export default defineAction({
  name: 'deploy',
  description: 'Execute deployment',
  async run({ tui, $ }) {
    // Check if interactive environment
    if (tui.control.isInteractive()) {
      // TUI environment: Rich feedback
      const spinner = tui.control.spinner({ message: 'Deploying...' })
      spinner.start()
      await $`npm run deploy`
      spinner.succeed('Deployment complete!')
    } else {
      // CI/CD environment: Simple output
      tui.output.log('Deploying...')
      await $`npm run deploy`
      tui.output.success('Deployment complete!')
    }
  }
})
```

### Using Environment Variables

In CI/CD environments, configuration and secrets are read from environment variables:

```typescript
import { defineAction } from 'arere'

export default defineAction({
  name: 'deploy',
  description: 'Deploy to production',
  async run({ env, $ }) {
    // Check required environment variables
    if (!env.API_KEY) {
      throw new Error('API_KEY environment variable is required')
    }

    if (!env.DEPLOY_URL) {
      throw new Error('DEPLOY_URL environment variable is required')
    }

    // Use environment variables
    await $`curl -X POST ${env.DEPLOY_URL} -H "Authorization: Bearer ${env.API_KEY}"`
  }
})
```

### Error Handling

In CI/CD environments, returning appropriate exit codes is important:

```typescript
import { defineAction } from 'arere'

export default defineAction({
  name: 'test',
  description: 'Run tests',
  async run({ $, tui }) {
    // Run tests
    const result = await $`npm test`

    if (result.exitCode !== 0) {
      tui.output.error('Tests failed')
      tui.output.code(result.stderr)
      // Exit process with non-zero exit code
      throw new Error('Test failed')
    }

    tui.output.success('All tests passed')
  }
})
```

::alert{type="info"}
Shell commands do not throw errors. Check success/failure with `result.exitCode`.
::

### GitHub Actions Usage Example

```yaml
# .github/workflows/test.yml
name: Test

on: [push]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '18'
      - run: npm install arere
      - run: npx arere run test
```

See the [GitHub Actions Integration Guide](/en/guides/github-actions/overview) for details.

---

## Complex Input Patterns

### Combining Multiple Inputs

```typescript
// ~/.arere/create-pr.ts
import { defineAction } from 'arere'

export default defineAction({
  name: 'create-pr',
  description: 'Create a pull request',
  category: 'git',
  async run({ $, tui }) {
    // 1. Get branch list
    const { stdout } = await $`git branch --format=%(refname:short)`
    const branches = stdout.split('\n').filter(Boolean)

    // 2. Select target branch
    const targetBranch = await tui.prompt.select('Target branch to merge into:', branches)

    // 3. Input title
    const title = await tui.prompt.text('PR title:', {
      validate: v => v.length > 0 || 'Please enter a title',
    })

    // 4. Input description
    const description = await tui.prompt.text('PR description:', {
      placeholder: 'Enter change details...',
    })

    // 5. Select reviewers
    const reviewers = await tui.prompt.multiSelect('Select reviewers:', [
      'alice',
      'bob',
      'charlie',
    ])

    // 6. Check if draft
    const isDraft = await tui.prompt.confirm('Create as draft PR?', { defaultValue: false })

    // 7. Confirmation
    tui.output.section('PR Information')
    tui.output.log(`  Title: ${title}`)
    tui.output.log(`  Target: ${targetBranch}`)
    tui.output.log(`  Reviewers: ${reviewers.join(', ')}`)
    tui.output.log(`  Draft: ${isDraft ? 'Yes' : 'No'}`)

    const confirmed = await tui.prompt.confirm('\nCreate PR with this information?', { defaultValue: true })

    if (!confirmed) {
      tui.output.warn('Cancelled')
      return
    }

    // 8. Create PR
    const draftFlag = isDraft ? '--draft' : ''
    const reviewerFlags = reviewers.map(r => `--reviewer ${r}`).join(' ')

    await $`gh pr create --title ${title} --body ${description} --base ${targetBranch} ${draftFlag} ${reviewerFlags}`

    tui.output.success('PR created')
  }
})
```

### Dynamic Action Selection

```typescript
// ~/.arere/docker-logs.ts
import { defineAction } from 'arere'

export default defineAction({
  name: 'docker-logs',
  description: 'Display Docker container logs',
  category: 'docker',
  async run({ $, tui }) {
    // Get container list
    const { stdout } = await $`docker ps --format {{.Names}}`
    const containers = stdout.split('\n').filter(Boolean)

    if (containers.length === 0) {
      tui.output.warn('No running containers')
      return
    }

    // Select container
    const container = await tui.prompt.select('Select container:', containers)

    // Confirm follow
    const follow = await tui.prompt.confirm('Follow logs?', { defaultValue: false })

    // Display logs
    const followFlag = follow ? '-f' : ''
    await $`docker logs ${container} ${followFlag}`
  }
})
```

### File Processing

```typescript
// ~/.arere/create-component.ts
import { defineAction } from 'arere'
import { writeFileSync, mkdirSync } from 'node:fs'
import { join } from 'node:path'

export default defineAction({
  name: 'create-component',
  description: 'Create a React component',
  async run({ tui }) {
    // Input component name
    const name = await tui.prompt.text('Component name:', {
      validate: (v) => {
        if (!/^[A-Z][a-zA-Z0-9]*$/.test(v)) {
          return 'Component name must be in PascalCase'
        }
        return true
      },
    })

    // Confirm if test file should also be created
    const withTest = await tui.prompt.confirm('Also create test file?', { defaultValue: true })

    // Create directory
    const dir = join(process.cwd(), 'src', 'components', name)
    mkdirSync(dir, { recursive: true })

    // Component file
    const componentContent = `\
import React from 'react'

export interface ${name}Props {
  // props
}

export const ${name}: React.FC<${name}Props> = (props) => {
  return (
    <div>
      ${name} Component
    </div>
  )
}
`
    writeFileSync(join(dir, `${name}.tsx`), componentContent)

    // Test file
    if (withTest) {
      const testContent = `\
import { describe, it, expect } from 'vitest'
import { render } from '@testing-library/react'
import { ${name} } from './${name}'

describe('${name}', () => {
  it('should render', () => {
    const { container } = render(<${name} />)
    expect(container).toBeTruthy()
  })
})
`
      writeFileSync(join(dir, `${name}.test.tsx`), testContent)
    }

    tui.output.success(`Component created: ${dir}`)
  }
})
```

---

## Internationalization (i18n)

You can make actions support multiple languages.

### Using the translations Property

You can embed translations directly in the action using the `translations` property of `defineAction()`:

```typescript
import { defineAction } from 'arere'

export default defineAction({
  name: 'greet',
  description: ({ t }) => t('description'),
  // Define translations
  translations: {
    en: {
      description: 'Greet someone',
      prompt_name: 'What is your name?',
      greeting: 'Hello, {{name}}!',
      farewell: 'Nice to meet you!'
    },
    ja: {
      description: 'Greet someone',
      prompt_name: 'What is your name?',
      greeting: 'Hello, {{name}}!',
      farewell: 'Nice to meet you!'
    }
  } as const,  // as const enables type inference
  async run({ t, tui }) {
    // Translated prompt message
    const name = await tui.prompt.text(t('prompt_name'))

    // Translated message (with variable interpolation)
    tui.output.log(t('greeting', { name }))
    tui.output.log(t('farewell'))
  }
})
```

### Benefits of i18n

1. **Single file**: Manage translations and code together
2. **Type-safe**: Translation keys are type-checked with `as const`
3. **Simple**: No additional file structure needed
4. **Portable**: Easy to share

### Important Points

**1. Don't forget `as const`**

Add `as const` to the translations object to enable type inference:

```typescript
translations: {
  en: { greeting: 'Hello!' },
  ja: { greeting: 'Hello!' }
} as const  // <- This is important!
```

**2. No namespace needed**

When using the `translations` property, the `t()` function is automatically scoped to the action, so the `ns` option is not needed:

```typescript
// Correct
t('greeting')

// Not needed (when using translations property)
t('greeting', { ns: 'my-action' })
```

**3. Using in description**

You can use translation keys in the description:

```typescript
defineAction({
  name: 'greet',
  description: ({ t }) => t('description'),  // Get from translations
  translations: {
    en: { description: 'Greet someone' },
    ja: { description: 'Greet someone' }
  } as const,
  // ...
})
```

See the [i18n Guide](/en/guides/i18n-guide) for details.

---

## Next Steps

- [Hands-on Tutorials](/en/guides/tutorials) - Learn step by step
- [defineAction API](/en/api/defineAction) - Action definition details
- [Prompt API](/en/api/prompt) - Getting user input
- [Control API](/en/api/tui-control) - Progress display and timing control
- [Shell Executor](/en/api/shell) - Executing shell commands
- [GitHub Actions Integration](/en/guides/github-actions/overview) - Use in CI/CD
- [Plugin Development Guide](/en/guides/plugins/creating) - How to create plugins
- [i18n Guide](/en/guides/i18n-guide) - Internationalization details
