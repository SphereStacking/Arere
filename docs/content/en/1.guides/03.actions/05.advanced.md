---
title: Advanced Techniques
description: Learn progress display, CI/CD actions, internationalization, and more
---

# Advanced Techniques

## Progress Display and Feedback

For long-running actions, providing progress display and feedback improves user experience.

### Spinner Display

You can display a spinner to indicate processing:

```typescript
// ~/.arere/install-deps.ts
import { defineAction } from 'arere'

export default defineAction({
  name: 'install-deps',
  description: 'Install dependency packages',
  async run({ tui, $ }) {
    const spinner = tui.control.spinner({ message: 'Installing packages...' })
    spinner.start()

    const result = await $`npm install`
    if (result.exitCode === 0) {
      spinner.succeed('Installation complete!')
    } else {
      spinner.fail('Installation failed')
      throw new Error(result.stderr)
    }
  }
})
```

Spinner messages can be updated dynamically:

```typescript
const spinner = tui.control.spinner({ message: 'Step 1/3...' })
spinner.start()

await step1()
spinner.update('Step 2/3...')

await step2()
spinner.update('Step 3/3...')

await step3()
spinner.succeed('All done!')
```

### Progress Bar

For processes where you know the progress percentage, a progress bar is useful:

```typescript
// ~/.arere/batch-process.ts
import { defineAction } from 'arere'

export default defineAction({
  name: 'batch-process',
  description: 'Batch process files',
  async run({ tui, $ }) {
    const files = ['file1.txt', 'file2.txt', 'file3.txt', 'file4.txt', 'file5.txt']

    const progress = tui.control.progress({
      total: files.length,
      message: 'Processing files...'
    })

    progress.start()

    for (const file of files) {
      await $`process ${file}`
      progress.increment()  // Increment by 1
    }

    progress.succeed('All files processed!')
  }
})
```

You can also set progress directly:

```typescript
const progress = tui.control.progress({ total: 100 })
progress.start()

for (let i = 0; i <= 100; i += 10) {
  await doWork(i)
  progress.update(i)  // 0, 10, 20, ..., 100
}

progress.succeed('Complete!')
```

### Waiting and Timing Control

You can add delays between processes or wait for user input:

```typescript
// ~/.arere/demo.ts
import { defineAction } from 'arere'

export default defineAction({
  name: 'demo',
  description: 'Demo action',
  async run({ tui }) {
    tui.output.info('Step 1')
    await tui.control.delay(1000)  // Wait 1 second

    tui.output.info('Step 2')
    await tui.control.delay(1000)

    tui.output.info('Complete!')

    // Wait for Enter key
    await tui.control.waitForEnter('Press Enter to continue...')
  }
})
```

See [TUI Control API](/api/tui-control) for details.

---

## CI/CD Actions

Considerations when creating actions for CI/CD environments.

### Headless Mode Support

In CI/CD environments, actions run in headless mode without UI display. Actions should be designed to work in both modes.

#### Detecting Interactive Mode

```typescript
import { defineAction } from 'arere'

export default defineAction({
  name: 'deploy',
  description: 'Execute deployment',
  async run({ tui, $ }) {
    // Check if interactive environment
    if (tui.control.isInteractive()) {
      // TUI environment: Rich feedback
      const spinner = tui.control.spinner({ message: 'Deploying...' })
      spinner.start()
      await $`npm run deploy`
      spinner.succeed('Deployment complete!')
    } else {
      // CI/CD environment: Simple output
      tui.output.log('Deploying...')
      await $`npm run deploy`
      tui.output.success('Deployment complete!')
    }
  }
})
```

### CLI Arguments

Actions can receive command-line arguments when executed via `arere run`:

```bash
arere run deploy production --force --verbose
```

```typescript
import { defineAction } from 'arere'

export default defineAction({
  name: 'deploy',
  description: 'Deploy to target environment',
  async run({ args, tui, $ }) {
    // args = ['production', '--force', '--verbose']
    const target = args[0] || 'staging'
    const force = args.includes('--force')
    const verbose = args.includes('--verbose')

    if (verbose) {
      tui.output.info(`Target: ${target}`)
      tui.output.info(`Force: ${force}`)
    }

    const forceFlag = force ? '--force' : ''
    await $`npm run deploy -- --env ${target} ${forceFlag}`

    tui.output.success(`Deployed to ${target}!`)
  }
})
```

::alert{type="info"}
When running from TUI (interactive mode), `args` is an empty array `[]`. Design actions to have sensible defaults or use prompts as fallback.
::

#### Combining Args with Prompts (Manual)

```typescript
import { defineAction } from 'arere'

export default defineAction({
  name: 'release',
  description: 'Create a release',
  async run({ args, tui, $ }) {
    // Use CLI arg if provided, otherwise prompt
    let version = args[0]
    if (!version) {
      version = await tui.prompt.text('Version number:', {
        placeholder: '1.0.0',
        validate: v => /^\d+\.\d+\.\d+$/.test(v) || 'Invalid version format'
      })
    }

    const dryRun = args.includes('--dry-run')

    if (dryRun) {
      tui.output.info(`[DRY RUN] Would release version ${version}`)
      return
    }

    await $`npm version ${version}`
    await $`git push --follow-tags`
    tui.output.success(`Released version ${version}!`)
  }
})
```

Usage:
```bash
# With args (non-interactive)
arere run release 1.2.3
arere run release 1.2.3 --dry-run

# Without args (interactive)
arere run release
# → Prompts for version
```

### Argument Mapping (Recommended)

A cleaner way to support both CLI arguments and interactive prompts is to use **argument mapping**. This allows you to specify which CLI arguments map to which prompt, and arere will automatically use the argument value if provided, otherwise show the interactive prompt.

#### Basic Usage

```typescript
import { defineAction } from 'arere'

export default defineAction({
  name: 'deploy',
  description: 'Deploy application',
  async run({ tui, $ }) {
    // If --target or -t is provided, use it; otherwise show prompt
    const target = await tui.prompt.select(
      'Deploy target',
      ['staging', 'production'],
      {
        arg: 'target',        // --target=production
        argShort: 't',        // -t production
        description: 'Deploy target environment',
      }
    )

    // If --yes or -y is provided, skip confirmation
    const confirmed = await tui.prompt.confirm(
      'Deploy to this environment?',
      {
        arg: 'yes',           // --yes
        argShort: 'y',        // -y
        description: 'Skip confirmation',
      }
    )

    if (!confirmed) return

    await $`deploy --env=${target}`
    tui.output.success(`Deployed to ${target}!`)
  }
})
```

Usage:
```bash
# Fully interactive
arere run deploy

# Partially specified (prompts for missing values)
arere run deploy --target=staging

# Fully headless (CI/CD)
arere run deploy --target=production --yes

# Short flags
arere run deploy -t production -y

# Show available arguments
arere run deploy --help
```

#### Argument Mapping Options

All prompt methods support these mapping options:

| Option | Type | Description |
|--------|------|-------------|
| `arg` | `string` | Long argument name (e.g., `'target'` for `--target`) |
| `argShort` | `string` | Short argument name (e.g., `'t'` for `-t`) |
| `argIndex` | `number` | Positional argument index (0-based) |
| `description` | `string` | Description shown in `--help` output |

#### Example with All Prompt Types

```typescript
import { defineAction } from 'arere'

export default defineAction({
  name: 'release',
  description: 'Create a release',
  async run({ tui, $ }) {
    // Text input: --version or first positional arg
    const version = await tui.prompt.text('Version', {
      arg: 'version',
      argIndex: 0,
      description: 'Release version (e.g., 1.0.0)',
      validate: v => /^\d+\.\d+\.\d+$/.test(v) || 'Invalid semver',
    })

    // Number input: --port
    const port = await tui.prompt.number('Port', {
      arg: 'port',
      argShort: 'p',
      description: 'Server port',
      min: 1024,
      max: 65535,
      defaultValue: 3000,
    })

    // Select: --env
    const env = await tui.prompt.select('Environment', ['dev', 'staging', 'prod'], {
      arg: 'env',
      argShort: 'e',
      description: 'Target environment',
    })

    // Confirm: --yes (flag)
    const confirmed = await tui.prompt.confirm('Proceed?', {
      arg: 'yes',
      argShort: 'y',
      description: 'Skip confirmation',
    })

    // Multi-select: --features (comma-separated)
    const features = await tui.prompt.multiSelect(
      'Features',
      ['api', 'web', 'mobile', 'docs'],
      {
        arg: 'features',
        argShort: 'f',
        description: 'Features to include (comma-separated)',
      }
    )

    // Password: --token
    const token = await tui.prompt.password('API Token', {
      arg: 'token',
      description: 'API authentication token',
    })

    tui.output.info(`Releasing ${version} to ${env}`)
    tui.output.info(`Port: ${port}`)
    tui.output.info(`Features: ${features.join(', ')}`)
    // ... execute release
  }
})
```

CLI usage:
```bash
# Full headless mode
arere run release 1.2.0 \
  --port=8080 \
  --env=prod \
  --yes \
  --features=api,web \
  --token=secret123

# Mixed mode
arere run release --env=staging
# → Prompts for version, port, features, etc.
```

#### Argument Format Reference

```bash
# Long arguments
--name=value         # = separated
--name value         # Space separated

# Short arguments
-n=value             # = separated
-nvalue              # Inline value

# Flags (for confirm prompts)
--yes                # true
-y                   # true
--yes=true           # true
--yes=false          # false

# Positional arguments (by index)
arere run deploy staging  # args[0] = 'staging'

# Multi-select (comma-separated)
--features=a,b,c
```

#### Help Display

When using argument mapping, users can view available arguments with `--help`:

```bash
$ arere run deploy --help

deploy - Deploy application

Options:
  -t, --target <staging|production>  Deploy target environment
  -y, --yes                          Skip confirmation

Usage:
  arere run deploy [options]
```

::alert{type="tip"}
Always add `description` to your argument mappings for better help output.
::

#### Non-Interactive Mode Behavior

In non-interactive mode (CI/CD), prompts with argument mapping will:
1. Use the CLI argument value if provided
2. Use the `defaultValue` if specified and no argument provided
3. Throw an error if required and no value available

```typescript
// This will throw in CI if --name is not provided
const name = await tui.prompt.text('Name', { arg: 'name' })

// This will use the default in CI if --name is not provided
const name = await tui.prompt.text('Name', {
  arg: 'name',
  defaultValue: 'anonymous',
})
```

### Using Environment Variables

In CI/CD environments, configuration and secrets are read from environment variables:

```typescript
import { defineAction } from 'arere'

export default defineAction({
  name: 'deploy',
  description: 'Deploy to production',
  async run({ env, $ }) {
    // Check required environment variables
    if (!env.API_KEY) {
      throw new Error('API_KEY environment variable is required')
    }

    if (!env.DEPLOY_URL) {
      throw new Error('DEPLOY_URL environment variable is required')
    }

    // Use environment variables
    await $`curl -X POST ${env.DEPLOY_URL} -H "Authorization: Bearer ${env.API_KEY}"`
  }
})
```

### Error Handling

In CI/CD environments, returning appropriate exit codes is important:

```typescript
import { defineAction } from 'arere'

export default defineAction({
  name: 'test',
  description: 'Run tests',
  async run({ $, tui }) {
    // Run tests
    const result = await $`npm test`

    if (result.exitCode !== 0) {
      tui.output.error('Tests failed')
      tui.output.code(result.stderr)
      // Exit process with non-zero exit code
      throw new Error('Test failed')
    }

    tui.output.success('All tests passed')
  }
})
```

::alert{type="info"}
Shell commands do not throw errors. Check success/failure with `result.exitCode`.
::

### GitHub Actions Usage Example

```yaml
# .github/workflows/test.yml
name: Test

on: [push]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '18'
      - run: npm install arere
      - run: npx arere run test
```

See the [GitHub Actions Integration Guide](/guides/github-actions/overview) for details.

---

## Complex Input Patterns

### Combining Multiple Inputs

```typescript
// ~/.arere/create-pr.ts
import { defineAction } from 'arere'

export default defineAction({
  name: 'create-pr',
  description: 'Create a pull request',
  category: 'git',
  async run({ $, tui }) {
    // 1. Get branch list
    const { stdout } = await $`git branch --format=%(refname:short)`
    const branches = stdout.split('\n').filter(Boolean)

    // 2. Select target branch
    const targetBranch = await tui.prompt.select('Target branch to merge into:', branches)

    // 3. Input title
    const title = await tui.prompt.text('PR title:', {
      validate: v => v.length > 0 || 'Please enter a title',
    })

    // 4. Input description
    const description = await tui.prompt.text('PR description:', {
      placeholder: 'Enter change details...',
    })

    // 5. Select reviewers
    const reviewers = await tui.prompt.multiSelect('Select reviewers:', [
      'alice',
      'bob',
      'charlie',
    ])

    // 6. Check if draft
    const isDraft = await tui.prompt.confirm('Create as draft PR?', { defaultValue: false })

    // 7. Confirmation
    tui.output.section('PR Information')
    tui.output.log(`  Title: ${title}`)
    tui.output.log(`  Target: ${targetBranch}`)
    tui.output.log(`  Reviewers: ${reviewers.join(', ')}`)
    tui.output.log(`  Draft: ${isDraft ? 'Yes' : 'No'}`)

    const confirmed = await tui.prompt.confirm('\nCreate PR with this information?', { defaultValue: true })

    if (!confirmed) {
      tui.output.warn('Cancelled')
      return
    }

    // 8. Create PR
    const draftFlag = isDraft ? '--draft' : ''
    const reviewerFlags = reviewers.map(r => `--reviewer ${r}`).join(' ')

    await $`gh pr create --title ${title} --body ${description} --base ${targetBranch} ${draftFlag} ${reviewerFlags}`

    tui.output.success('PR created')
  }
})
```

### Dynamic Action Selection

```typescript
// ~/.arere/docker-logs.ts
import { defineAction } from 'arere'

export default defineAction({
  name: 'docker-logs',
  description: 'Display Docker container logs',
  category: 'docker',
  async run({ $, tui }) {
    // Get container list
    const { stdout } = await $`docker ps --format {{.Names}}`
    const containers = stdout.split('\n').filter(Boolean)

    if (containers.length === 0) {
      tui.output.warn('No running containers')
      return
    }

    // Select container
    const container = await tui.prompt.select('Select container:', containers)

    // Confirm follow
    const follow = await tui.prompt.confirm('Follow logs?', { defaultValue: false })

    // Display logs
    const followFlag = follow ? '-f' : ''
    await $`docker logs ${container} ${followFlag}`
  }
})
```

### File Processing

```typescript
// ~/.arere/create-component.ts
import { defineAction } from 'arere'
import { writeFileSync, mkdirSync } from 'node:fs'
import { join } from 'node:path'

export default defineAction({
  name: 'create-component',
  description: 'Create a React component',
  async run({ tui }) {
    // Input component name
    const name = await tui.prompt.text('Component name:', {
      validate: (v) => {
        if (!/^[A-Z][a-zA-Z0-9]*$/.test(v)) {
          return 'Component name must be in PascalCase'
        }
        return true
      },
    })

    // Confirm if test file should also be created
    const withTest = await tui.prompt.confirm('Also create test file?', { defaultValue: true })

    // Create directory
    const dir = join(process.cwd(), 'src', 'components', name)
    mkdirSync(dir, { recursive: true })

    // Component file
    const componentContent = `\
import React from 'react'

export interface ${name}Props {
  // props
}

export const ${name}: React.FC<${name}Props> = (props) => {
  return (
    <div>
      ${name} Component
    </div>
  )
}
`
    writeFileSync(join(dir, `${name}.tsx`), componentContent)

    // Test file
    if (withTest) {
      const testContent = `\
import { describe, it, expect } from 'vitest'
import { render } from '@testing-library/react'
import { ${name} } from './${name}'

describe('${name}', () => {
  it('should render', () => {
    const { container } = render(<${name} />)
    expect(container).toBeTruthy()
  })
})
`
      writeFileSync(join(dir, `${name}.test.tsx`), testContent)
    }

    tui.output.success(`Component created: ${dir}`)
  }
})
```

---

## Internationalization (i18n)

You can make actions support multiple languages.

### Using the translations Property

You can embed translations directly in the action using the `translations` property of `defineAction()`:

```typescript
import { defineAction } from 'arere'

export default defineAction({
  name: 'greet',
  description: ({ t }) => t('description'),
  // Define translations
  translations: {
    en: {
      description: 'Greet someone',
      prompt_name: 'What is your name?',
      greeting: 'Hello, {{name}}!',
      farewell: 'Nice to meet you!'
    },
    ja: {
      description: 'Greet someone',
      prompt_name: 'What is your name?',
      greeting: 'Hello, {{name}}!',
      farewell: 'Nice to meet you!'
    }
  } as const,  // as const enables type inference
  async run({ t, tui }) {
    // Translated prompt message
    const name = await tui.prompt.text(t('prompt_name'))

    // Translated message (with variable interpolation)
    tui.output.log(t('greeting', { name }))
    tui.output.log(t('farewell'))
  }
})
```

### Benefits of i18n

1. **Single file**: Manage translations and code together
2. **Type-safe**: Translation keys are type-checked with `as const`
3. **Simple**: No additional file structure needed
4. **Portable**: Easy to share

### Important Points

**1. Don't forget `as const`**

Add `as const` to the translations object to enable type inference:

```typescript
translations: {
  en: { greeting: 'Hello!' },
  ja: { greeting: 'Hello!' }
} as const  // <- This is important!
```

**2. No namespace needed**

When using the `translations` property, the `t()` function is automatically scoped to the action, so the `ns` option is not needed:

```typescript
// Correct
t('greeting')

// Not needed (when using translations property)
t('greeting', { ns: 'my-action' })
```

**3. Using in description**

You can use translation keys in the description:

```typescript
defineAction({
  name: 'greet',
  description: ({ t }) => t('description'),  // Get from translations
  translations: {
    en: { description: 'Greet someone' },
    ja: { description: 'Greet someone' }
  } as const,
  // ...
})
```

See the [i18n Guide](/guides/i18n-guide) for details.

---

## Next Steps

- [Tutorials](/guides/tutorials) - Learn step by step
- [defineAction API](/api/define-action) - Action definition details
- [Prompt API](/api/prompt) - Getting user input
- [Control API](/api/tui-control) - Progress display and timing control
- [Shell Executor](/api/shell) - Executing shell commands
- [GitHub Actions Integration](/guides/github-actions/overview) - Use in CI/CD
- [Plugin Development Guide](/guides/plugins/creating) - How to create plugins
- [i18n Guide](/guides/i18n-guide) - Internationalization details
