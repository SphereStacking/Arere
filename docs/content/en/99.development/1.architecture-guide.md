---
title: Architecture Guide
description: Arere's feature-based architecture design and implementation guide
---

# Architecture Guide

## Overview

The Arere project uses a **Feature-based Architecture** where related code is grouped by feature rather than by technical layer.

**Design Principles**:
- Group related code together (types, logic, utilities)
- Easy to find files - "where would X be?"
- Minimize cross-feature dependencies
- Keep it simple and intuitive

---

## Directory Structure

```
src/
├── cli.ts                # CLI entry point
├── index.ts              # Library API exports
│
├── action/               # Action system
│   ├── types.ts          # Action, ActionContext, ActionMeta types
│   ├── define.ts         # defineAction() helper
│   ├── context.ts        # createActionContext()
│   ├── executor.ts       # runAction()
│   ├── loader.ts         # Dynamic loading with jiti
│   ├── registry.ts       # ActionRegistry (last-wins)
│   ├── resolver.ts       # Action path resolution
│   ├── cache.ts          # Action cache
│   └── args/             # CLI argument handling
│       ├── parser.ts
│       ├── validator.ts
│       └── prompt-wrapper.ts
│
├── plugin/               # Plugin system
│   ├── types.ts          # ArerePlugin, PluginMeta, LoadedPlugin
│   ├── define.ts         # definePlugin() helper
│   ├── manager.ts        # PluginManager
│   ├── detector.ts       # Plugin detection (npm packages)
│   ├── loader.ts         # Plugin loading with jiti
│   ├── resolver.ts       # Plugin path resolution
│   ├── service.ts        # PluginService (toggle, enable/disable)
│   └── index.ts          # Public exports
│
├── config/               # Configuration management
│   ├── schema.ts         # Zod schemas + defaultConfig
│   ├── manager.ts        # FileConfigManager (read/write)
│   ├── service.ts        # ConfigService (side effects)
│   ├── paths.ts          # Config file path resolution
│   ├── types.ts          # ConfigLayer types
│   ├── utils.ts          # Merge utilities
│   ├── errors.ts         # Config-specific errors
│   └── override-detector.ts
│
├── i18n/                 # Internationalization
│   ├── index.ts          # initI18n(), t(), registerTranslations()
│   ├── manager.ts        # TranslationManager
│   ├── scoped.ts         # createScopedT()
│   ├── types.ts          # Translation key types
│   └── utils.ts          # Interpolation utilities
│
├── shell/                # Shell execution
│   ├── executor.ts       # $ tagged template executor
│   └── index.ts          # Public exports
│
├── modes/                # Execution modes
│   ├── ui-mode.ts        # Interactive TUI mode
│   ├── headless-mode.ts  # CLI mode (arere run)
│   └── types.ts          # Mode types
│
├── ui/                   # Terminal UI (React/Ink)
│   ├── App.tsx           # Main application
│   ├── AppContext.tsx    # Application context
│   │
│   ├── screens/          # Screen components
│   │   ├── home/
│   │   ├── search/
│   │   ├── execution/
│   │   ├── settings/
│   │   ├── prompt/
│   │   └── help/
│   │
│   ├── components/       # Shared components
│   │   ├── Header.tsx
│   │   ├── Footer.tsx
│   │   ├── ActionList.tsx
│   │   ├── inputs/       # Input components
│   │   └── ...
│   │
│   ├── stores/           # Zustand stores
│   │   ├── screenStore.ts
│   │   ├── settingsStore.ts
│   │   ├── executionStore.ts
│   │   └── promptStore.ts
│   │
│   ├── hooks/            # React hooks
│   │   ├── useActionExecution.ts
│   │   ├── useConfigManagement.ts
│   │   ├── usePluginManagement.ts
│   │   └── ...
│   │
│   ├── prompts/          # Prompt implementations
│   │   ├── renderer.ts
│   │   ├── text.ts
│   │   ├── select.ts
│   │   ├── confirm.ts
│   │   └── form/
│   │
│   ├── output/           # Output rendering
│   │   ├── collector.ts
│   │   └── plain-renderer.ts
│   │
│   ├── keybindings/      # Keybinding system
│   │   ├── defaults.ts
│   │   ├── matcher.ts
│   │   └── parser.ts
│   │
│   ├── control/          # Visual feedback
│   │   ├── spinner.ts
│   │   ├── progress.ts
│   │   └── timing.ts
│   │
│   └── kaomoji/          # Kaomoji faces
│
└── lib/                  # Shared utilities
    ├── logger.ts         # pino-based logger
    ├── error.ts          # Error formatting
    ├── path.ts           # Path utilities
    └── types.ts          # Common types
```

---

## Feature Modules

### Action Module (`action/`)

The action system handles loading, registration, and execution of user-defined actions.

**Key Components**:
- `defineAction()` - Helper to define actions with type safety
- `loadAction()` - Dynamic loading using jiti
- `ActionRegistry` - Map-based registry with "last-wins" semantics
- `createActionContext()` - Creates execution context with all APIs

**Example**:
```typescript
// User defines an action
export default defineAction({
  description: 'Say hello',
  translations: {
    en: { greeting: 'Hello!' },
    ja: { greeting: 'こんにちは！' }
  },
  async run({ tui, t }) {
    tui.output.info(t('greeting'))
  }
})

// Internal: Loading and execution
const action = await loadAction('/path/to/action.ts')
registry.register(action)
const result = await runAction(action)
```

### Plugin Module (`plugin/`)

The plugin system detects, loads, and manages npm-based plugins.

**Key Components**:
- `definePlugin()` - Helper to define plugins
- `detectPlugins()` - Scans node_modules for `arere-plugin-*`
- `PluginManager` - Manages plugin lifecycle
- `PluginService` - Handles enable/disable operations

**Plugin Lifecycle**:
1. **Detection**: Scan `node_modules/` for `arere-plugin-*` packages
2. **Loading**: Load plugin definition using jiti
3. **Validation**: Validate user config against schema
4. **Registration**: Register plugin i18n + load actions
5. **Hot-reload**: Enable/disable via Settings UI

### Config Module (`config/`)

Configuration management with VSCode-style layered config.

**Key Components**:
- `FileConfigManager` - Unified read/write operations
- `ConfigService` - Side effects (locale change, log level)
- Zod schemas for validation

**Layer Priority**: workspace > user > defaults

**Example**:
```typescript
const manager = new FileConfigManager()
const config = await manager.loadMerged()  // Merged config

await manager.save('workspace', 'locale', 'ja')  // Save to .arere/settings.json
```

### i18n Module (`i18n/`)

Internationalization with namespace-based translations.

**Key Components**:
- `TranslationManager` - Core translation engine
- `createScopedT()` - Namespace-isolated translation function
- `registerTranslations()` - Dynamic registration for actions/plugins

**Namespaces**: `common`, `cli`, `ui`, `errors`, plus action/plugin namespaces

### UI Module (`ui/`)

Terminal UI built with React and Ink.

**Key Concepts**:
- **Screens**: Full-screen views (home, search, settings, etc.)
- **Stores**: Zustand for state management
- **Hooks**: Custom hooks for business logic
- **Prompts**: Two-layer async prompt system

**Screen Flow**:
```
HomeScreen → SearchScreen → ExecutingScreen → SuccessScreen/ErrorScreen
     ↓
SettingsScreen → PluginListScreen → PluginDetailScreen
```

### Shell Module (`shell/`)

Shell command execution using tagged template literals.

**Example**:
```typescript
const result = await $`npm run build`
// Returns: { stdout, stderr, exitCode }

// Safe interpolation
const name = 'hello world'
const result = await $`echo ${name}`  // Properly escaped
```

---

## Path Alias

All imports use the `@/` path alias:

```typescript
// tsconfig.json
{
  "compilerOptions": {
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}

// Usage
import { logger } from '@/lib/logger.js'
import { defineAction } from '@/action/define.js'
import type { Action } from '@/action/types.js'
```

---

## Data Flow

### Action Execution Flow

```
User selects action in HomeScreen
  ↓
useActionExecution.executeAction()
  ↓
runAction(action) in action/executor.ts
  ├─→ createActionContext()
  │    ├─→ createScopedT() for translations
  │    ├─→ createShellExecutor() for $
  │    └─→ createOutputAPI() for tui.output
  │
  └─→ action.run(context)
       ├─→ tui.prompt.* (queued, resolved by PromptScreen)
       ├─→ tui.output.* (collected, rendered by OutputRenderer)
       └─→ $`command` (executed, returns result)
  ↓
Result returned to UI
  ↓
SuccessScreen or ErrorScreen
```

### Configuration Change Flow

```
User changes setting in SettingsScreen
  ↓
useConfigManagement.handleConfigChange()
  ↓
ConfigService.changeConfig()
  ├─→ applySideEffects() (locale, logLevel, etc.)
  └─→ manager.save() → writeFile()
  ↓
manager.loadMerged() → get correct merge result
  ↓
setCurrentConfig(newConfig)
  ↓
UI re-renders
```

---

## Testing Strategy

See the [Testing Guide](/development/testing-guide) for detailed patterns.

### Test Organization

```
tests/
├── unit/           # Unit tests by feature
│   ├── action/
│   ├── plugin/
│   ├── config/
│   ├── i18n/
│   └── ui/
├── integration/    # Multi-module tests
└── e2e/           # End-to-end workflow tests
```

### Coverage Targets

- Overall: 90%+
- Core logic (action, plugin, config): 95%+
- UI components: 85%+

---

## Key Design Decisions

### Why Feature-based?

1. **Intuitive navigation**: "Where is plugin loading?" → `plugin/loader.ts`
2. **Reduced cognitive load**: Related code lives together
3. **Easier refactoring**: Changes are localized to features
4. **Simpler imports**: `@/plugin/` instead of `@/infrastructure/plugin/`

### Why Not Clean Architecture?

For a CLI tool like Arere:
- Layers add complexity without proportional benefit
- Most "business logic" is straightforward
- External dependencies are limited (fs, shell)
- Feature cohesion matters more than layer separation

### Guiding Principles

1. **YAGNI**: Don't add abstractions until needed
2. **Colocation**: Keep related code together
3. **Simplicity**: Prefer simple solutions over "proper" architecture
4. **Pragmatism**: Architecture serves the code, not the other way around

---

## Reference

- `CLAUDE.md` - Quick reference for development
- [Testing Guide](/development/testing-guide) - Test patterns and strategies
