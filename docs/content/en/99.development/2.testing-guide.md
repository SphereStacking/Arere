---
title: Testing Guide
description: TDD principles and test patterns for each layer
---

# Testing Guide

## Overview

This project adopts **Test-Driven Development (TDD)**.
We define appropriate test patterns and mock strategies for each layer to maintain a high-quality codebase.

---

## TDD (Test-Driven Development)

### TDD Cycle (Red-Green-Refactor)

```
1. üî¥ Red: Write a test (failing test)
   ‚Üì
2. üü¢ Green: Write minimum code to make test pass
   ‚Üì
3. üîµ Refactor: Improve code (while keeping tests passing)
   ‚Üì
(repeat)
```

### TDD Principles

- ‚úÖ **Test First**: Always write tests before implementation
- ‚úÖ **Minimum Implementation**: Write only the minimum code to pass tests
- ‚úÖ **Refactoring**: Improve code quality while tests are passing
- ‚úÖ **High Coverage**: Target 90%+ test coverage

### Why TDD?

**Benefits**:
1. **Design Improvement**: Testable code is naturally loosely coupled
2. **Refactoring Safety**: Can improve code while confirming tests aren't broken
3. **Documentation**: Tests serve as specifications
4. **Early Bug Detection**: Bugs found immediately after implementation
5. **Confidence**: Can change code with assurance when tests exist

---

## Test Patterns per Layer

### Core Layer Testing

**Test Targets**:
- Action loading logic
- Registry operations
- Path resolution

**Test Pattern**:
```typescript
// tests/unit/core/loader.test.ts
import { describe, it, expect } from 'vitest'
import { loadActions } from '@/core/loader.js'

describe('loadActions', () => {
  it('should load valid action files', async () => {
    // üî¥ Red: Write test first
    const paths = ['/path/to/action.ts']
    const actions = await loadActions(paths)

    expect(actions).toHaveLength(1)
    expect(actions[0].meta.name).toBe('test-action')
  })

  it('should skip invalid files gracefully', async () => {
    const paths = ['/path/to/invalid.ts']
    const actions = await loadActions(paths)

    expect(actions).toHaveLength(0)
  })
})
```

**Characteristics**:
- No jiti mocking needed (verify with real files)
- Tests with temporary directories
- Error handling tests

---

### Domain Layer Testing

**Test Targets**:
- Type definition validation (TypeScript compiler)
- Business logic (pure functions)

**Test Pattern**:
```typescript
// tests/unit/domain/action/defineAction.test.ts
import { describe, it, expect } from 'vitest'
import { defineAction } from '@/domain/action/defineAction.js'

describe('defineAction', () => {
  it('should create action with provided metadata', () => {
    const action = defineAction({
      name: 'test',
      description: 'Test action',
      category: 'test',
      run: async (ctx) => {},
    })

    expect(action.meta.name).toBe('test')
    expect(action.meta.description).toBe('Test action')
    expect(action.meta.category).toBe('test')
  })

  it('should derive name from filename if not provided', () => {
    // Test first to clarify specification
    const action = defineAction({
      description: 'Test',
      run: async () => {},
    })

    expect(action.meta.name).toBeDefined()
  })
})
```

**Characteristics**:
- Pure function testing
- No side effects
- No mocks needed

---

### Infrastructure Layer Testing

**Test Targets**:
- File I/O
- External system integration
- Config loading/writing

**Test Pattern**:
```typescript
// tests/unit/infrastructure/config/loader.test.ts
import { describe, it, expect, beforeEach, afterEach } from 'vitest'
import { mkdtempSync, rmSync, writeFileSync } from 'node:fs'
import { join } from 'node:path'
import { tmpdir } from 'node:os'
import { loadLayeredConfig } from '@/infrastructure/config/loader.js'

describe('loadLayeredConfig', () => {
  let tempDir: string

  beforeEach(() => {
    // Create temporary directory
    tempDir = mkdtempSync(join(tmpdir(), 'arere-test-'))
  })

  afterEach(() => {
    // Cleanup
    rmSync(tempDir, { recursive: true, force: true })
  })

  it('should load and merge workspace and user configs', async () => {
    // üî¥ Red: Test first
    const userConfig = { locale: 'en' }
    const workspaceConfig = { locale: 'ja' }

    writeFileSync(
      join(tempDir, 'user.json'),
      JSON.stringify(userConfig)
    )
    writeFileSync(
      join(tempDir, 'workspace.json'),
      JSON.stringify(workspaceConfig)
    )

    const config = await loadLayeredConfig()

    // Workspace takes priority over User
    expect(config.locale).toBe('ja')
  })
})
```

**Characteristics**:
- File I/O tests with temporary directories
- Cleanup with `beforeEach` / `afterEach`
- External commands can be mocked

---

### Application Layer Testing

**Test Targets**:
- Business workflows
- Multi-layer coordination

**Test Pattern**:
```typescript
// tests/unit/application/ConfigService.test.ts
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { ConfigService } from '@/application/services/ConfigService.js'

// Mock Infrastructure layer
vi.mock('@/infrastructure/config/partial-save.js', () => ({
  savePartialConfig: vi.fn(),
}))

vi.mock('@/infrastructure/i18n/index.js', () => ({
  changeLocale: vi.fn(),
}))

describe('ConfigService', () => {
  let service: ConfigService

  beforeEach(() => {
    service = new ConfigService()
    vi.clearAllMocks()
  })

  it('should change config and apply side effects', async () => {
    // üî¥ Red: Workflow test
    const currentConfig = { locale: 'en' }

    const newConfig = await service.changeConfig(
      currentConfig,
      'locale',
      'ja',
      'workspace'
    )

    expect(newConfig.locale).toBe('ja')
    expect(changeLocale).toHaveBeenCalledWith('ja')
    expect(savePartialConfig).toHaveBeenCalledWith(
      'workspace',
      'locale',
      'ja'
    )
  })
})
```

**Characteristics**:
- Mock Infrastructure layer
- Test entire workflow
- Side effect verification

---

### Presentation Layer Testing

**Test Targets**:
- UI components
- User operations
- State management

**Test Pattern**:
```typescript
// tests/unit/presentation/ui/ActionList.test.tsx
import { describe, it, expect, vi } from 'vitest'
import { render } from 'ink-testing-library'
import React from 'react'
import { ActionList } from '@/presentation/ui/components/action/ActionList.js'

// Mock useInput
let capturedHandler: ((input: string, key: any) => void) | null = null

vi.mock('ink', async () => {
  const actual = await vi.importActual('ink')
  return {
    ...actual,
    useInput: (handler: (input: string, key: any) => void) => {
      capturedHandler = handler
    },
  }
})

describe('ActionList', () => {
  it('should render action list', () => {
    const actions = [
      { meta: { name: 'test', description: 'Test action' } },
    ]

    const { lastFrame } = render(
      <ActionList actions={actions} selectedIndex={0} />
    )

    expect(lastFrame()).toContain('test')
    expect(lastFrame()).toContain('Test action')
  })

  it('should handle keyboard navigation', () => {
    const onSelect = vi.fn()
    const actions = [
      { meta: { name: 'action1' } },
      { meta: { name: 'action2' } },
    ]

    render(
      <ActionList
        actions={actions}
        selectedIndex={0}
        onSelect={onSelect}
      />
    )

    // Down arrow to move
    capturedHandler?.('', { downArrow: true })

    // Enter key to select
    capturedHandler?.('', { return: true })

    expect(onSelect).toHaveBeenCalledWith(actions[1])
  })
})
```

**Characteristics**:
- Use `ink-testing-library`
- Mock `useInput`
- Mock Application layer
- Simulate keyboard operations

---

## Test Execution Commands

### Basic Commands

```bash
# Run all tests
npm test

# Watch mode
npm run test:watch

# Run with coverage
npm run test:coverage

# Run specific file only
npm test -- --run path/to/test.test.ts

# Run benchmarks
npm run bench
```

### CI/CD Environment

```bash
# For CI (run once)
npm test -- --run

# Generate coverage report
npm run test:coverage -- --reporter=json --reporter=html
```

---

## Mock Best Practices

### 1. Actively Mock Infrastructure Layer

Mock Infrastructure layer in tests since it interacts with external systems.

```typescript
vi.mock('@/infrastructure/config/loader.js', () => ({
  loadLayeredConfig: vi.fn().mockResolvedValue({ locale: 'en' }),
}))
```

**Reasons**:
- Ensure test stability by removing external dependencies
- Speed up tests
- No need to prepare external resources

### 2. No Mocks Needed for Domain Layer (Pure Functions)

Domain layer contains pure functions, so test directly without mocks.

```typescript
// No mocks needed
import { defineAction } from '@/domain/action/defineAction.js'
```

**Reasons**:
- Pure functions always return same output for same input
- No side effects
- No need to mock

### 3. Only Mock Infrastructure Layer for Application Layer

In Application layer tests, only mock Infrastructure layer, not Application layer itself.

```typescript
// Don't mock Application layer itself
// Only mock Infrastructure layer
vi.mock('@/infrastructure/config/partial-save.js', () => ({
  savePartialConfig: vi.fn(),
}))
```

**Reasons**:
- To test Application layer business logic
- Only eliminate Infrastructure layer side effects

### 4. Selectively Mock External Libraries

Don't mock entire external libraries, only mock necessary parts.

```typescript
// Only mock Ink's useInput (actually render)
vi.mock('ink', async () => {
  const actual = await vi.importActual('ink')
  return {
    ...actual,
    useInput: vi.fn(),
  }
})
```

**Reasons**:
- Can verify actual rendering behavior
- Mocks don't become too complex
- Tests closer to actual behavior

---

## Test Naming Conventions

### describe Blocks

- Use file name, class name, or function name
- Nest to represent hierarchy

```typescript
describe('ConfigService', () => {
  describe('changeConfig', () => {
    // Test cases
  })

  describe('loadConfig', () => {
    // Test cases
  })
})
```

### it Blocks

Use `should + verb` pattern and clearly describe what's being tested.

```typescript
describe('ConfigService', () => {
  describe('changeConfig', () => {
    it('should update config value', () => {})
    it('should apply side effects', () => {})
    it('should save to file', () => {})
    it('should throw error when validation fails', () => {})
  })
})
```

**Good Examples**:
- `it('should return empty array when no actions found')`
- `it('should throw error when file does not exist')`
- `it('should merge user and workspace configs')`

**Bad Examples**:
- `it('test config')`
- `it('works correctly')`
- `it('config test case 1')`

---

## Test Coverage

### Coverage Targets

Coverage targets by layer:
- **Core Layer**: 90%+
- **Domain Layer**: 95%+
- **Infrastructure Layer**: 85%+
- **Application Layer**: 95%+
- **Presentation Layer**: 80%+
- **Shared Layer**: 100%

### Coverage Report

```bash
# Generate coverage report
npm run test:coverage

# View HTML report
open coverage/index.html
```

### Coverage Philosophy

**Don't Aim for 100%**:
- Coverage is just one quality indicator
- Focus on test significance
- Write meaningful tests rather than formal ones

**Cases Where Low Coverage is OK**:
- Error handling edge cases
- Type definition only files
- External library wrappers

---

## Test Anti-patterns

### ‚ùå Patterns to Avoid

**1. Implementation Changes for Testing**:
```typescript
// ‚ùå Bad: Making public just for testing
export class ConfigService {
  public internalMethod() {} // Made public for testing
}

// ‚úÖ Good: Test through public methods
export class ConfigService {
  private internalMethod() {}
  public changeConfig() {
    this.internalMethod()
  }
}
```

**2. Excessive Mocking**:
```typescript
// ‚ùå Bad: Mock everything
vi.mock('@/domain/action/types.js')
vi.mock('@/domain/action/defineAction.js')

// ‚úÖ Good: Minimum necessary
// Domain layer is pure functions, no mocks needed
```

**3. Fragile Tests**:
```typescript
// ‚ùå Bad: Depends on implementation details
expect(component.state.internalCounter).toBe(5)

// ‚úÖ Good: Test behavior
expect(lastFrame()).toContain('Count: 5')
```

---

## Reference Resources

- [Vitest Official Documentation](https://vitest.dev/)
- [ink-testing-library](https://github.com/vadimdemedes/ink-testing-library)
- [Test-Driven Development by Example (Kent Beck)](https://www.amazon.com/Test-Driven-Development-Kent-Beck/dp/0321146530)
- [t-wada's TDD Materials](https://speakerdeck.com/twada)
