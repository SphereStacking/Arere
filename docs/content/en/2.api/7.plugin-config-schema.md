---
title: Plugin Config Schema API
description: API reference for defining and using plugin configuration schemas in Arere
---

# Plugin Config Schema API

This document explains the API for defining and using plugin configuration schemas in Arere.

## Overview

Plugins can define configuration schemas using [Zod](https://zod.dev/), which provides:

- **Type Safety**: TypeScript types inferred from schemas
- **Runtime Validation**: Automatic validation of user configuration
- **Default Values**: Sensible defaults for all options
- **Auto-generated UI**: Forms generated from schema definitions
- **Error Messages**: Clear validation error messages

## Table of Contents

- [Basic Usage](#basic-usage)
- [Schema Definition](#schema-definition)
- [Supported Field Types](#supported-field-types)
- [Accessing Configuration](#accessing-configuration)
- [Configuration File Format](#configuration-file-format)
- [Type Inference](#type-inference)
- [Validation](#validation)
- [Best Practices](#best-practices)
- [Complete Example](#complete-example)

## Basic Usage

### 1. Define Schema in Plugin

```typescript
// src/index.ts
import { z } from 'zod'
import { definePlugin } from 'arere'

export const configSchema = z.object({
  apiKey: z.string()
    .default('')
    .describe('API authentication key'),

  timeout: z.number()
    .min(1000)
    .max(30000)
    .default(5000)
    .describe('Request timeout in milliseconds'),

  retries: z.number()
    .min(0)
    .max(5)
    .default(3)
    .describe('Number of retry attempts'),

  verbose: z.boolean()
    .default(false)
    .describe('Enable verbose logging'),
})

export type PluginConfig = z.infer<typeof configSchema>

export default definePlugin({
  meta: {
    name: 'arere-plugin-example',
    version: '1.0.0',
    description: 'Example plugin with configuration',
  },
  actions: ['./actions/example.ts'],
  configSchema,  // ← Include schema
})
```

### 2. Use Configuration in Actions

```typescript
// actions/example.ts
import { defineAction } from 'arere'
import type { PluginConfig } from '../src/index.js'

export default defineAction({
  name: 'example-action',
  description: 'Use plugin configuration',
  async run({ tui, pluginConfig }) {
    // Type-safe access to configuration
    const config = pluginConfig as PluginConfig

    const apiKey = config.apiKey || 'default-key'
    const timeout = config.timeout || 5000
    const retries = config.retries || 3

    if (config.verbose) {
      tui.output.log(`Timeout: ${timeout}ms, Retries: ${retries}`)
    }

    // Use configuration...
  },
})
```

### 3. User Configuration

```json
// .arere/settings.json
{
  "plugins": {
    "arere-plugin-example": {
      "enabled": true,
      "config": {
        "apiKey": "sk-1234567890",
        "timeout": 10000,
        "retries": 5,
        "verbose": true
      }
    }
  }
}
```

## Schema Definition

### ArerePlugin Interface

```typescript
interface ArerePlugin {
  meta: {
    name: string
    version: string
    description?: string
    author?: string
  }
  actions: string[]
  localesPath?: string
  configSchema?: z.ZodObject<any>  // ← Configuration schema
}
```

### Schema Requirements

- Must be a `z.ZodObject` (other Zod types not supported)
- All fields should have `.default()` values
- All fields should have `.describe()` descriptions
- Field names should be camelCase
- Use appropriate validators (`.min()`, `.max()`, `.email()`, etc.)

## Supported Field Types

### String

```typescript
z.string()
  .default('default-value')
  .describe('Field description')
  .min(1)                      // Optional: minimum length
  .max(100)                    // Optional: maximum length
  .email()                     // Optional: email validation
  .url()                       // Optional: URL validation
```

**UI Representation**: Text input field

### Number

```typescript
z.number()
  .default(10)
  .describe('Numeric value')
  .min(1)                      // Optional: minimum value
  .max(100)                    // Optional: maximum value
  .int()                       // Optional: integers only
  .positive()                  // Optional: positive numbers
```

**UI Representation**: Number input field with validation

### Boolean

```typescript
z.boolean()
  .default(false)
  .describe('Enable/disable feature')
```

**UI Representation**: Toggle switch

### Enum

```typescript
z.enum(['option1', 'option2', 'option3'])
  .default('option1')
  .describe('Select an option')
```

**UI Representation**: Radio button selection

### Optional Field

```typescript
z.string().optional()         // Field is optional
  .describe('Optional setting')
```

### Nested Objects

```typescript
z.object({
  database: z.object({
    host: z.string().default('localhost'),
    port: z.number().default(5432),
  }).default({ host: 'localhost', port: 5432 }),
})
```

**Note**: Nested objects are supported but UI generation is limited to 1 level of depth.

## Accessing Configuration

### In Plugin Actions

Configuration is passed through the `pluginConfig` field in the execution context:

```typescript
export default defineAction({
  name: 'my-action',
  description: 'My action',
  async run({ tui, pluginConfig }) {
    // Cast to configuration type
    const config = pluginConfig as MyPluginConfig

    // Access with fallback
    const apiKey = config?.apiKey || 'default'
    const timeout = config?.timeout || 5000

    // Use configuration...
  },
})
```

### Type Safety

```typescript
// Define type from schema
export type MyConfig = z.infer<typeof configSchema>

// Use in action
export default defineAction({
  name: 'typed-action',
  description: 'Action with typed config',
  async run({ pluginConfig }) {
    const config = pluginConfig as MyConfig

    // TypeScript knows the types!
    config.apiKey    // string
    config.timeout   // number
    config.verbose   // boolean
  },
})
```

## Configuration File Format

### Simple Enable/Disable

```json
{
  "plugins": {
    "plugin-name": true,   // Enable with defaults
    "another-plugin": false // Disable
  }
}
```

### With Configuration

```json
{
  "plugins": {
    "plugin-name": {
      "enabled": true,
      "config": {
        "key1": "value1",
        "key2": 42,
        "key3": true
      }
    }
  }
}
```

### Omitting Fields (Use Defaults)

```json
{
  "plugins": {
    "plugin-name": {
      "enabled": true,
      "config": {
        "apiKey": "custom-key"
        // All other fields use schema defaults
      }
    }
  }
}
```

## Type Inference

Zod provides automatic type inference:

```typescript
export const configSchema = z.object({
  name: z.string().default(''),
  count: z.number().default(0),
  enabled: z.boolean().default(false),
})

// Infer TypeScript type
export type Config = z.infer<typeof configSchema>

// Equivalent to:
// type Config = {
//   name: string
//   count: number
//   enabled: boolean
// }
```

## Validation

### Automatic Validation

Arere automatically validates user configuration against the schema:

```typescript
const configSchema = z.object({
  port: z.number().min(1000).max(65535),
  email: z.string().email(),
})

// Valid configuration
{ port: 3000, email: 'user@example.com' }  // ✅ Passes

// Invalid configuration
{ port: 100, email: 'user@example.com' }   // ❌ Port too low
{ port: 3000, email: 'invalid' }           // ❌ Invalid email
{ email: 'user@example.com' }              // ❌ Missing port
```

### Custom Validation

```typescript
const configSchema = z.object({
  password: z.string()
    .min(8, 'Password must be at least 8 characters')
    .regex(/[A-Z]/, 'Password must contain uppercase letter')
    .regex(/[0-9]/, 'Password must contain a number'),
})
```

### Validation Errors

When validation fails, Arere displays clear error messages:

```
Configuration Error: arere-plugin-example
- timeout: Number must be between 1000 and 30000
- email: Invalid email address
```

## Best Practices

### 1. Always Provide Defaults

```typescript
// ✅ Good
z.string().default('sensible-default')

// ❌ Bad
z.string()  // No default
```

### 2. Add Descriptions

```typescript
// ✅ Good
z.boolean()
  .default(false)
  .describe('Enable automatic backup')

// ❌ Bad
z.boolean().default(false)  // No description
```

### 3. Use Appropriate Validators

```typescript
// ✅ Good
z.number()
  .min(1000)
  .max(30000)
  .default(5000)

// ❌ Bad
z.number().default(5000)  // No validation
```

### 4. Export Config Type

```typescript
// ✅ Good
export const configSchema = z.object({ /* ... */ })
export type PluginConfig = z.infer<typeof configSchema>

// ❌ Bad
const configSchema = z.object({ /* ... */ })  // Not exported
```

### 5. Handle Missing Configuration Gracefully

```typescript
// ✅ Good
async run({ pluginConfig }) {
  const config = pluginConfig as MyConfig
  const apiKey = config?.apiKey || 'fallback'
}

// ❌ Bad
async run({ pluginConfig }) {
  const apiKey = pluginConfig.apiKey  // May crash if undefined
}
```

### 6. Document Configuration Options

Include configuration option descriptions in your README:

```markdown
## Configuration

- `apiKey` (string): API authentication key
- `timeout` (number): Request timeout in milliseconds (1000-30000)
- `retries` (number): Number of retry attempts (0-5)
- `verbose` (boolean): Enable verbose logging
```

## Complete Example

### Plugin Definition

```typescript
// src/index.ts
import { z } from 'zod'
import { definePlugin } from 'arere'

export const configSchema = z.object({
  // String field with validation
  apiKey: z.string()
    .min(1, 'API key is required')
    .default('')
    .describe('API authentication key'),

  // Number field with range
  timeout: z.number()
    .min(1000, 'Timeout must be at least 1 second')
    .max(30000, 'Timeout cannot exceed 30 seconds')
    .default(5000)
    .describe('Request timeout in milliseconds'),

  // Enum field
  environment: z.enum(['development', 'staging', 'production'])
    .default('development')
    .describe('Deployment environment'),

  // Boolean field
  verbose: z.boolean()
    .default(false)
    .describe('Enable verbose logging'),

  // Optional field
  webhookUrl: z.string()
    .url('Must be a valid URL')
    .optional()
    .describe('Optional webhook notification URL'),

  // Nested object
  database: z.object({
    host: z.string().default('localhost'),
    port: z.number().min(1).max(65535).default(5432),
    ssl: z.boolean().default(false),
  }).default({ host: 'localhost', port: 5432, ssl: false })
    .describe('Database connection settings'),
})

export type DeployPluginConfig = z.infer<typeof configSchema>

export default definePlugin({
  meta: {
    name: 'arere-plugin-deploy',
    version: '1.0.0',
    description: 'Deploy automation plugin',
    author: 'Your Name',
  },
  actions: ['./actions/deploy.ts'],
  configSchema,
})
```

### Using Configuration

```typescript
// actions/deploy.ts
import { defineAction } from 'arere'
import type { DeployPluginConfig } from '../src/index.js'

export default defineAction({
  name: 'deploy',
  description: 'Deploy to environment',
  async run({ tui, pluginConfig }) {
    const config = pluginConfig as DeployPluginConfig

    // Type-safe access with IntelliSense
    const env = config.environment || 'development'
    const timeout = config.timeout || 5000

    if (config.verbose) {
      tui.output.log(`Deploying to ${env}...`)
      tui.output.log(`Timeout: ${timeout}ms`)
    }

    // Deploy logic using configuration...

    if (config.webhookUrl) {
      // Send webhook notification
    }
  },
})
```

### User Configuration

```json
{
  "plugins": {
    "arere-plugin-deploy": {
      "enabled": true,
      "config": {
        "apiKey": "sk-prod-1234567890",
        "timeout": 15000,
        "environment": "production",
        "verbose": true,
        "webhookUrl": "https://hooks.slack.com/...",
        "database": {
          "host": "db.example.com",
          "port": 5432,
          "ssl": true
        }
      }
    }
  }
}
```

## Related Documentation

- [Plugin Configuration Guide](/en/1.guides/04.plugins/03.config) - User guide
- [Plugin Development](/en/1.guides/04.plugins/02.creating) - Plugin development
- [Zod Documentation](https://zod.dev/) - Zod schema validation library

## Summary

Plugin configuration schemas provide:

- **Type Safety** - With TypeScript inference
- **Runtime Validation** - With clear error messages
- **Auto-generated UI** - For easy configuration
- **Sensible Defaults** - Zero-config operation
- **Developer Friendly** - API powered by Zod

Start by defining a simple schema with default values, then add validation and descriptions as needed. Users can configure plugins through the UI or by editing `.arere/settings.json`.
