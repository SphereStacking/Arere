---
title: Architecture Guide
description: Arere's layered architecture design and implementation guide
---

# Architecture Guide

## Overview

The Arere project is designed based on **Clean Architecture / Layered Architecture**.

**Design Principles**:
- Separation of business logic and UI logic
- Improved testability
- Enhanced maintainability and extensibility
- Strict adherence to Single Responsibility Principle (SRP)

---

## Layer Structure

### Layer Separation Principles

```
┌─────────────────────────────────────┐
│   Presentation Layer                │  ← User interaction
│   - React/Ink Components            │
│   - UI Hooks                        │
│   - Modes (UI/Headless)             │
└──────────────┬──────────────────────┘
               │ calls
┌──────────────▼──────────────────────┐
│   Application Layer                 │  ← Use case execution
│   - Services (orchestration)        │
│   - ConfigService                   │
│   - PluginService                   │
└──────────────┬──────────────────────┘
               │ uses
┌──────────────▼──────────────────────┐
│   Domain Layer                      │  ← Business logic
│   - Action Types                    │
│   - Type Definitions                │
│   - Pure Functions (minimal)        │
└──────────────┬──────────────────────┘
               │ depends on
┌──────────────▼──────────────────────┐
│   Infrastructure Layer              │  ← External systems
│   - File I/O (config, plugin)       │
│   - i18n                            │
│   - Shell Execution                 │
│   - Prompt System                   │
│   - Output Rendering                │
└─────────────────────────────────────┘
         ↕
┌─────────────────────────────────────┐
│   Shared Layer                      │  ← Common utilities
│   - Logger                          │
│   - Error Handling                  │
│   - Path Utilities                  │
└─────────────────────────────────────┘
```

**Dependency Rules**:
- Upper layers can depend on lower layers
- Lower layers must not depend on upper layers
- Domain layer can only import types from Infrastructure layer
- Shared layer can be used from all layers

---

## Directory Structure

```
src/
├── cli.ts                           # CLI entry point
├── index.ts                         # Library API exports
│
├── core/                            # Core layer (Action loading system)
│   ├── loader.ts                    # Dynamic Action loading with jiti
│   ├── registry.ts                  # ActionRegistry (last-wins)
│   ├── resolver.ts                  # Action path resolution
│   └── cache.ts                     # Action cache
│
├── domain/                          # Domain layer
│   ├── action/                      # Action type definitions & business logic
│   │   ├── types.ts                 # Action, ActionContext, ActionMeta
│   │   ├── context.ts               # createActionContext
│   │   ├── executor.ts              # runAction
│   │   └── defineAction.ts          # defineAction helper
│   ├── plugin/                      # Plugin type definitions & business logic
│   │   ├── types.ts                 # ArerePlugin, PluginMeta, LoadedPlugin
│   │   ├── definePlugin.ts          # definePlugin() helper (Pure function)
│   │   └── manager.ts               # PluginManager (dependency injection pattern)
│   └── types/                       # Common type definitions
│       ├── control.ts               # VisualFeedback, ControlAPI
│       └── common.ts                # Common types
│
├── infrastructure/                  # Infrastructure layer (External systems)
│   ├── config/                      # Configuration management (Unified Manager API)
│   │   ├── manager.ts               # FileConfigManager unified implementation (read/write)
│   │   ├── errors.ts                # Config-specific error classes
│   │   ├── schema.ts                # Zod schema definitions + defaultConfig
│   │   ├── types.ts                 # ConfigLayer and other type definitions
│   │   ├── utils.ts                 # Utility functions (merge, nested-value)
│   │   ├── override-detector.ts     # Override detection
│   │   └── paths.ts                 # Config file paths
│   │
│   ├── plugin/                      # Plugin system (Infrastructure layer)
│   │   ├── detector.ts              # Plugin detection via npm (FS dependent)
│   │   ├── loader.ts                # Plugin loading (jiti dependent)
│   │   ├── resolver.ts              # Plugin path resolution (system command dependent)
│   │   └── index.ts                 # createPluginManager() factory function
│   │
│   ├── i18n/                        # Internationalization (i18next)
│   │   ├── index.ts                 # i18n initialization
│   │   ├── scoped-translation.ts    # Scoped translation
│   │   ├── registerTranslations.ts  # Dynamic translation registration
│   │   └── types.ts                 # Type-safe translation keys (auto-generated)
│   │
│   ├── shell/                       # Shell execution
│   │   └── executor.ts              # $ tagged template executor
│   │
│   ├── prompt/                      # Prompt system
│   │   ├── renderer.ts              # PromptRenderer (2-layer prompt)
│   │   ├── text.ts                  # text()
│   │   ├── select.ts                # select()
│   │   ├── confirm.ts               # confirm()
│   │   ├── multiSelect.ts           # multiSelect()
│   │   └── backends/
│   │       └── readline-backend.ts  # Headless mode readline
│   │
│   ├── integrations/                # External tool integrations
│   │   ├── tmux.ts                  # tmux integration
│   │   └── zellij.ts                # zellij integration
│   │
│   └── output/                      # Output rendering
│       └── plain-renderer.ts        # PlainTextRenderer
│
├── application/                     # Application layer
│   └── services/                    # Business logic coordination
│       ├── ConfigService.ts         # Configuration change workflow
│       └── PluginService.ts         # Plugin management workflow
│
├── presentation/                    # Presentation layer
│   ├── ui/                          # React/Ink UI
│   │   ├── layouts/
│   │   │   ├── App.tsx              # Main application
│   │   │   └── Header.tsx           # Header
│   │   │
│   │   ├── components/              # Reusable components
│   │   │   ├── action/
│   │   │   │   ├── ActionList.tsx
│   │   │   │   └── ActionFuzzySearch.tsx
│   │   │   ├── prompt/
│   │   │   │   ├── PromptRenderer.tsx
│   │   │   │   └── parts/          # Input parts
│   │   │   ├── settings/
│   │   │   │   ├── LayerSelector.tsx
│   │   │   │   └── OverrideIndicator.tsx
│   │   │   └── routing/
│   │   │       └── ScreenRouter.tsx
│   │   │
│   │   ├── pages/                   # Screen components
│   │   │   ├── execution/
│   │   │   │   ├── Executing.tsx
│   │   │   │   ├── Success.tsx
│   │   │   │   └── Error.tsx
│   │   │   ├── help/
│   │   │   │   └── Help.tsx
│   │   │   └── settings/
│   │   │       ├── Settings.tsx
│   │   │       ├── components/
│   │   │       ├── hooks/
│   │   │       └── plugins/
│   │   │
│   │   ├── hooks/                   # Custom hooks
│   │   │   ├── app/                 # Application state
│   │   │   │   ├── useAppState.ts
│   │   │   │   ├── useKeyboardInput.ts
│   │   │   │   ├── useActionExecution.ts
│   │   │   │   ├── useConfigManagement.ts
│   │   │   │   └── usePluginManagement.ts
│   │   │   └── useTerminalSize.ts
│   │   │
│   │   ├── control/                 # Timing & feedback control
│   │   │   ├── types.ts
│   │   │   ├── timing.ts
│   │   │   ├── spinner.ts
│   │   │   ├── progress.ts
│   │   │   └── terminal.ts
│   │   │
│   │   ├── types.ts                 # UI type definitions
│   │   ├── schema-to-fields.ts      # Zod schema → UI fields conversion
│   │   └── utils/
│   │       └── action.ts
│   │
│   └── modes/                       # Execution modes
│       ├── ui-mode.tsx              # Interactive UI
│       └── headless-mode.ts         # Headless mode for CI/CD
│
└── shared/                          # Shared layer (usable from all layers)
    └── utils/
        ├── logger.ts                # pino-based logger
        ├── error.ts                 # Error formatting
        └── path.ts                  # Path utilities
```

---

## Layer Responsibilities and Implementation Examples

### 1. Core Layer

**Responsibilities**:
- Dynamic Action loading (using jiti)
- ActionRegistry management
- Path resolution & caching

**Implementation Example**:
```typescript
// src/core/loader.ts
export async function loadActions(paths: string[]): Promise<Action[]> {
  const actions: Action[] = []

  for (const filePath of paths) {
    try {
      const action = await loadAction(filePath)  // Dynamic loading with jiti
      actions.push(action)
    } catch (error) {
      logger.warn(`Failed to load action: ${filePath}`, error)
    }
  }

  return actions
}

// src/core/registry.ts
export class ActionRegistry {
  private actions = new Map<string, Action>()

  register(action: Action): void {
    // Last-wins: later registrations take priority
    this.actions.set(action.meta.name, action)
  }
}
```

### 2. Domain Layer

**Responsibilities**:
- Action type definitions
- Common type definitions
- Business logic (minimal)

**Characteristics**:
- Can import types from Infrastructure layer
- Pure functions recommended (not required)

**Implementation Example**:
```typescript
// src/domain/action/types.ts
export interface Action<TKeys extends string = string> {
  meta: ActionMeta
  filePath: string
  run: (context: ActionContext<TKeys>) => Promise<void>
  translations?: Record<string, Record<string, unknown>>
  pluginNamespace?: string
  pluginMeta?: import('@/domain/plugin/types.js').PluginMeta
}

export interface ActionContext<TKeys extends string = string> {
  tui: TUIAPI
  $: ShellExecutor
  env: Record<string, string | undefined>
  t: TranslationFunction<TKeys>
  cwd: string
  pluginConfig?: Record<string, unknown>
  config: import('@/infrastructure/config/schema.js').ArereConfig  // Merged config
}

// src/domain/action/defineAction.ts
export function defineAction<TKeys extends string = string>(
  definition: ActionDefinition<TKeys>
): Action<TKeys> {
  // Action definition helper function
  return {
    meta: {
      name: definition.name || deriveNameFromFilename(),
      description: definition.description,
      category: definition.category,
      tags: definition.tags,
    },
    filePath: '',  // Set by loader
    run: definition.run,
    translations: definition.translations,
  }
}
```

### 3. Infrastructure Layer

**Responsibilities**:
- Interaction with external systems
- File I/O
- Hiding technical details

**Unified Manager Pattern (Repository/Writer Integration)**:
- Read/Write operations integrated into a single class (FileConfigManager)
- Simple API without DI
- Single Source of Truth (centralized merge logic)
- **Key Improvements**:
  - Elimination of Repository/Writer separation (9 files → 6 files, -33%)
  - Removal of DI pattern (more intuitive API)
  - Improved type safety (removal of `@ts-expect-error`)

**Implementation Example**:
```typescript
// src/infrastructure/config/manager.ts (Unified Manager)
export class FileConfigManager {
  private cwd: string

  constructor(cwd: string = process.cwd()) {
    this.cwd = cwd
  }

  // --- Read Operations ---

  async loadMerged(cwd: string = this.cwd): Promise<ArereConfig> {
    const layered = await this.loadAll(cwd)
    return mergeConfigs(layered)  // workspace > user > defaults
  }

  async loadLayer(layer: ConfigLayer, cwd: string = this.cwd): Promise<Partial<ArereConfig> | null> {
    const configPath = getConfigPath(layer, cwd)
    return await this.loadConfigFile(configPath)
  }

  // --- Write Operations ---

  async save(layer: ConfigLayer, key: string, value: unknown, cwd: string = this.cwd): Promise<void> {
    const configPath = getConfigPath(layer, cwd)

    // 1. Load existing config
    const existing = await this.loadRawConfigFile(configPath)

    // 2. Update nested value (using setNestedValue from utils.ts)
    const updated = setNestedValue(current || {}, key, value)

    // Write to file (integrated low-level API)
    await this.saveConfigObjectToFile(configPath, updated)
  }
}

// src/infrastructure/plugin/detector.ts
export async function detectPlugins(): Promise<string[]> {
  // Detect plugins installed via npm
  const globalModulesPath = await getGlobalNodeModulesPath()
  const localModulesPath = join(process.cwd(), 'node_modules')

  const plugins: string[] = []

  for (const modulesPath of [globalModulesPath, localModulesPath]) {
    if (!existsSync(modulesPath)) continue

    const dirs = readdirSync(modulesPath)
    const pluginDirs = dirs.filter(dir => dir.startsWith('arere-plugin-'))
    plugins.push(...pluginDirs)
  }

  return [...new Set(plugins)]  // Remove duplicates
}
```

### 4. Application Layer

**Responsibilities**:
- Coordination between Domain and Infrastructure layers
- Business workflow execution
- Side effect orchestration

**Simple Instantiation (DI Removed)**:
- FileConfigManager instantiated internally (simple API)
- FileConfigManager mocked in tests
- Maintaining Single Source of Truth

**Implementation Example**:
```typescript
// src/application/services/ConfigService.ts (using Unified Manager)
export class ConfigService {
  private manager: FileConfigManager

  constructor(cwd?: string) {
    this.manager = new FileConfigManager(cwd)
  }

  /**
   * Change config, apply side effects, and save to file
   */
  async changeConfig(
    key: string,
    value: unknown,
    layer: ConfigLayer = 'workspace',
    cwd?: string
  ): Promise<ArereConfig> {
    // 1. Apply side effects
    await this.applySideEffects(key, value)

    // 2. Save to file
    await this.manager.save(layer, key, value, cwd)

    // 3. Reload from file (get correct merge result)
    const newConfig = await this.manager.loadMerged(cwd)

    return newConfig
  }

  private async applySideEffects(key: string, value: unknown): Promise<void> {
    if (key === 'locale') {
      await changeLocale(value as string)
    } else if (key === 'logLevel') {
      setLogLevel(value as LogLevel)
    }
  }
}
```

### 5. Presentation Layer

**Responsibilities**:
- User interaction
- State management (React State)
- Calling Application layer

**Implementation Example**:
```typescript
// src/presentation/ui/hooks/app/useConfigManagement.ts
export function useConfigManagement({
  currentConfig,
  setCurrentConfig,
  reloadLayerConfigs,
  setScreen,
}: UseConfigManagementProps) {
  // Simple instantiation of Application layer service
  const configService = useMemo(() => {
    return new ConfigService()
  }, [])

  const handleConfigChange = useCallback(async (
    key: string,
    value: unknown,
    layer: ConfigLayer = 'workspace'
  ) => {
    try {
      // Just call Application layer
      const newConfig = await configService.changeConfig(key, value, layer)

      // Update UI state
      setCurrentConfig(newConfig)

      // Reload layer-specific configs
      await reloadLayerConfigs()
    } catch (error) {
      logger.error('Failed to change config', error)
    }
  }, [configService, setCurrentConfig, reloadLayerConfigs])

  return { handleConfigChange, handleConfigReset, handlePluginConfigRequest }
}
```

### 6. Shared Layer

**Responsibilities**:
- Common utilities usable from all layers

**Implementation Example**:
```typescript
// src/shared/utils/logger.ts
import pino from 'pino'

let logger = pino({
  level: 'info',
  transport: {
    target: 'pino-pretty',
    options: {
      colorize: true,
      translateTime: 'HH:MM:ss',
      ignore: 'pid,hostname',
    },
  },
})

export function setLogLevel(level: LogLevel): void {
  logger.level = level
}

export { logger }
```

---

## Path Alias System

### Path Alias Configuration

```typescript
// tsconfig.json
{
  "compilerOptions": {
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}

// vitest.config.ts
export default defineConfig({
  resolve: {
    alias: {
      '@': resolve(__dirname, './src'),
    },
  },
})
```

### Import Examples

```typescript
// ✅ Using path alias (recommended)
import { logger } from '@/shared/utils/logger.js'
import { ConfigService } from '@/application/services/ConfigService.js'
import type { Action } from '@/domain/action/types.js'
import { FileConfigManager } from '@/infrastructure/config/manager.js'  // Unified Manager

// ❌ Relative paths (not recommended)
import { logger } from '../../../shared/utils/logger.js'
```

---

## Data Flow

### Configuration Change Flow (Unified Manager Pattern)

```
User: Changes locale in Settings screen
  ↓
Settings.tsx (Presentation)
  ↓
useConfigManagement.handleConfigChange() (Presentation)
  ↓
ConfigService.changeConfig() (Application)
  ├─→ applySideEffects()
  │    ├─→ changeLocale() (Infrastructure - i18n)
  │    └─→ setLogLevel() (Shared - logger)
  │
  ├─→ manager.save() (Infrastructure - FileConfigManager)
  │    └─→ writeFile() (Node.js fs)
  │
  └─→ manager.loadMerged() (Infrastructure - FileConfigManager)
       └─→ Get correct merge result (workspace > user > defaults)
  ↓
Return newConfig
  ↓
setCurrentConfig(newConfig) (Presentation)
reloadLayerConfigs() (Presentation)
  ↓
UI re-renders (React state update)
```

**Important Changes**:
- ✅ **Single Source of Truth**: Merge logic only in Manager.loadMerged()
- ✅ **Correct Priority**: Always reflects correct priority by reloading from file
- ✅ **Simple API**: Intuitive instantiation without DI

---

## Test Strategy

This project adopts **Test-Driven Development (TDD)**.

For detailed test patterns and mock strategies, see the [Testing Guide](/en/4.development/2.testing-guide).

### Test Strategy Overview

**Approach per Layer**:
- **Core Layer**: Integration tests with real files
- **Domain Layer**: Unit tests of pure functions (no mocks needed)
- **Infrastructure Layer**: I/O tests with temporary directories
- **Application Layer**: Workflow tests with Infrastructure layer mocked
- **Presentation Layer**: UI tests using `ink-testing-library`

### Coverage Targets

Coverage targets by layer:
- Core Layer: 90%+
- Domain Layer: 95%+
- Infrastructure Layer: 85%+
- Application Layer: 95%+
- Presentation Layer: 80%+
- Shared Layer: 100%

---

## Benefits

### 1. Improved Testability
- Easy testing through Application layer separation
- Each layer can be tested independently
- Easy mocking

### 2. Improved Maintainability
- Clear responsibilities for each layer
- Directory structure clarifies roles
- Easy to add new features

### 3. Improved Readability
- Concise imports with path alias (`@/*`)
- Clear file roles
- Intuitive directory structure

### 4. Build Stability
- Static verification through TypeScript type checking
- Clear dependencies
- Early detection of build errors

---

## Extension Guidelines

### Implemented Patterns

1. ✅ **Unified Manager Pattern**
   - Read/Write operations integrated into one class (FileConfigManager)
   - Simple API without DI
   - Maintaining Single Source of Truth

2. ✅ **Architecture Simplification**
   - **Phase 1**: Infrastructure/Config layer: 14 files → 9 files (-36%)
   - **Phase 2**: Infrastructure/Config layer: 9 files → 6 files (-33%)

### Future Extension Options

1. **Context Introduction**: When props drilling becomes problematic
2. **Domain Layer Extension**: When complex business logic increases
3. **Use Cases Layer**: When complex workflows increase
4. **DI Container**: When constructor injection management becomes complex

### YAGNI Principle Compliance

**Currently Not Needed**:
- ❌ Complex abstract classes
- ❌ Use Cases layer (Service is sufficient)
- ❌ DI Container (useMemo is sufficient)

**Add When Needed**:
- ✅ Keep it simple
- ✅ Address problems when they actually occur
- ✅ Avoid over-abstraction

---

## Reference Documentation

- `context-design.md` - React Context design
- `CLAUDE.md` - Overall project architecture overview
