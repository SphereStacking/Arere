# 実装プラン作成ガイド

このコマンドは、新しい機能や改善を実装する際のプランニングガイドです。

## 重要

- 実装は明確に開始の合図があるまでは、プランニングを続けてください。
- v1リリース前のため大胆な設計変更が可能です
- 設計変更に伴う後方互換は必要ありません。クリーンな実装をお願いします。



## プラン作成の流れ

### 1. プランファイルを作成

**まず、次のphase番号を確認してください：**

```bash
ls plan/ | grep -E '^phase-[0-9]+' | sort -t'-' -k2 -n | tail -5
```

このコマンドで最新のphase番号を確認し、次の番号を使用してください。

新しいフェーズを `plan/` ディレクトリに作成します：

```bash
plan/
├── phase-0-foundation.md          # 基盤構築（完了）
├── phase-1-core.md                # コア機能（完了）
├── ...
└── phase-XX-new-feature.md        # 次の機能（新規作成）
```

### 2. テンプレートを使用

以下のテンプレートに従ってプランを作成します。

### 3. 仕様書の参照

現在の仕様書は以下を参照：
- **アーキテクチャ**: `docs/content/ja/3.development/1.architecture-guide.md`
- **テスト**: `docs/content/ja/3.development/2.testing-guide.md`
- **CLAUDE.md**: プロジェクト概要と開発ポリシー

## タスクファイルのテンプレート

各フェーズファイルは以下のテンプレートに従って作成します：

```markdown
# フェーズX: [フェーズ名]

## プランニングステータス

**重要**
必ずこちらが承認されている場合のみ実装を開始すること

- **ステータス**: プランニング中/承認/却下/ペンディング



## 概要
- **目的**: このフェーズで達成すること
- **前提条件**: 必要な前フェーズ
- **参照ドキュメント**:
  - 主要: [ドキュメント名](パス)
  - 補助: [ドキュメント名](パス)
- **推定期間**: X日
- **ステータス**: ⚪ 未着手

## タスクリスト

### セクション1: [セクション名]

#### タスク1.1: [タスク名]
- **詳細**: 具体的な作業内容
- **仕様参照**: [該当セクション名](ドキュメントパス#セクション)
- **見積**: Xh
- **実績**: -
- **ステータス**: ⚪
- **成果物**:
  - `path/to/file.ts`

#### タスク1.2: [タスク名]
- **詳細**: 具体的な作業内容
- **仕様参照**: [該当セクション名](ドキュメントパス#セクション)
- **見積**: Xh
- **実績**: -
- **ステータス**: ⚪
- **成果物**:
  - `path/to/file.ts`

## 成果物一覧
- ディレクトリ/ファイルのリスト
- 設定ファイル
- ドキュメント

## 受入条件
- [ ] 条件1: 具体的な確認項目
- [ ] 条件2: 具体的な確認項目
- [ ] 条件3: 具体的な確認項目

## PRチェックリスト
PR作成前に以下を確認すること：

### コード品質
- [ ] `npm run lint` が通る（フォーマット含む）
- [ ] `npm run typecheck` が通る
- [ ] `npm test` が通る

### i18n対応（該当する場合）
- [ ] ハードコードされた文字列がない
- [ ] `translations` キーを使用（`i18n` ではない）
- [ ] 日本語・英語の両方を追加
- [ ] タグは英語のみ（翻訳不要）

### アクション追加時
- [ ] `description` は `({ t }) => t('description')` 形式
- [ ] `category` は適切なカテゴリ（例: `arere-dev`）
- [ ] `tags` は配列形式で英語

### コミット整理
- [ ] 意味のある単位でコミットが分かれている
- [ ] 不要なfixupコミットがまとめられている

### 型定義変更時
- [ ] stubsテンプレートも更新されている（`packages/arere-plugin-create/stubs/`）
- [ ] テストのモックデータも更新されている

### リリース時
- [ ] 影響を受ける全パッケージをリリース
- [ ] グローバルインストール (`npm i -g`) で動作確認

## 依存関係
- **前提**: フェーズX完了
- **ブロッカー**: なし
- **次フェーズ**: フェーズY

## メモ
- 注意事項
- 参考リンク
- 決定事項
```

## ステータス記号

- ⚪ 未着手
- 🟡 進行中
- 🟢 完了
- 🔴 ブロック

## プランニングのベストプラクティス

### 1. アーキテクチャを考慮

新機能を追加する際は、Clean Architecture のどの層に配置すべきか検討：
- **Domain層**: ビジネスロジック
- **Infrastructure層**: 外部システム連携
- **Application層**: ユースケース調整
- **Presentation層**: UI

参考: [アーキテクチャガイド](../../docs/content/ja/3.development/1.architecture-guide.md)

### 2. テストファースト

TDD原則に従い、テストを含めたタスクを計画：
- テストケースの洗い出し
- モック戦略の検討
- カバレッジ目標の設定

参考: [テストガイド](../../docs/content/ja/3.development/2.testing-guide.md)

### 3. 小さく分割

大きな機能は小さなタスクに分割：
- 1タスク = 1-4時間
- 独立してテスト可能
- レビューしやすい単位

### 4. 成果物を明確に

各タスクで何を作るのか明確に：
- ファイルパス
- 型定義
- テストファイル
- ドキュメント更新

### 5. 受入条件を定義

フェーズ完了の基準を明確に：
- テストが通る
- 型チェックが通る
- カバレッジが目標に達する
- ドキュメントが更新されている

## 実装の進め方

### 1. プラン作成
```
新しい機能 → plan/phase-X-feature.md 作成
```

### 2. タスク実行
```
タスク1.1 → 実装 → テスト → ステータス更新
```

### 3. レビュー
```
タスク完了 → 受入条件確認 → 次タスクへ
```

### 4. フェーズ完了
```
全タスク完了 → ドキュメント更新 → 次フェーズへ
```

## 注意事項

### プラグイン・アクション作成時は必ず create コマンドを使用

プラグインやアクションを新規作成する場合、**手動で作成せず必ず以下のコマンドを使用**してください：

```bash
# アクション作成
npx arere
# → [create] create-action を選択

# プラグイン作成
npx arere
# → [create] create-plugin を選択
```

**理由:**
- 正しいディレクトリ構造が保証される
- 必要な設定ファイル（tsconfig.json, package.json）が自動生成される
- i18n設定が正しくセットアップされる
- テンプレートが最新の型定義に準拠している

**手動作成は禁止です。** テンプレートの更新漏れや設定ミスの原因になります。

### アクション定義の注意点

アクションで翻訳を使う場合：
- **正しいキー**: `translations`（型定義で定義されている）
- **間違い**: `i18n`（プラグインでは使えるがアクションでは使えない）

```typescript
// ✅ 正しい
export default defineAction({
  description: ({ t }) => t('description'),
  translations: {
    en: { description: 'English description' },
    ja: { description: '日本語の説明' },
  },
})

// ❌ 間違い - descriptionが翻訳されない
export default defineAction({
  description: ({ t }) => t('description'),
  i18n: { ... },  // アクションでは認識されない
})
```

### コミット整理の手順

複数のfixupコミットを整理する方法：

```bash
# 方法1: soft resetして再コミット
git reset --soft origin/main
git add <file1>
git commit -m "feat: 機能A"
git add <file2>
git commit -m "fix: 修正B"

# 方法2: interactive rebase
git rebase -i origin/main
# エディタでpick/fixup/squashを編集
```

意味のある単位の例：
- 新機能追加 + その機能のi18n対応 → 1コミット
- 既存ファイルの修正（カテゴリ変更など） → 別コミット

### アーキテクチャ変更時
- アーキテクチャガイドを先に更新
- 影響範囲を明確に
- 既存コードの移行計画も立てる

### テスト方針変更時
- テストガイドを先に更新
- 既存テストへの影響を確認
- 移行期間を設ける

### ドキュメント更新を忘れない
- CLAUDE.md は概要のみ
- 詳細は development guide に集約
- 相互リンクを活用

## 参考: 過去のフェーズ

完了済みのフェーズ例：
- **Phase 0-22**: 基盤構築、コア機能、UI実装、プラグインシステム
- **Phase 23**: Script → Action リネーム（250+ occurrences）
- **Phase 39**: Settings Layer Selector UI
- **Phase 40**: Partial Config Save
- **Phase 43**: Clean Architecture / レイヤー分離

詳細は `plan/` ディレクトリを参照してください。
